Index: Realization/MatrixTransformations.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using AKG.Realization.Elements;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Numerics;\r\nusing static System.Numerics.Matrix4x4;\r\n\r\nnamespace AKG.Realization\r\n{\r\n    public static class MatrixTransformations\r\n    {\r\n        //создаем матрицу для приведения к мировым координатам\r\n        //Shift - сдвиг по осям Rotate - поворот по осям Scale - масштаб\r\n        public static Vector4 TransformToWordMatrix(Vector4 vertex, float ShiftX, float ShiftY, float ShiftZ,\r\n            float RotateX, float RotateY, float RotateZ, float scale)\r\n        {\r\n            var worldMatr = CreateTranslation(ShiftX, ShiftY, ShiftZ) // матрица для сдвига\r\n                            * CreateRotationX(RotateX) * CreateRotationY(RotateY) *\r\n                            CreateRotationZ(RotateZ) // матрицы для поворотов\r\n                            * CreateScale(scale); // матрица для масштаба\r\n            return Transform(vertex, worldMatr);\r\n        }\r\n\r\n        // Создает матрицу, которая преобразует координаты из мирового пространства в пространство наблюдателя.\r\n        // eye - Позиция камеры (где она находится).\r\n        // target - Позиция цели (куда смотрит камера).\r\n        // up - Вектор \"вверх\" (обычно (0,1,0))\r\n        public static Vector4 TransformToViewMatrix(Vector4 vertex, Vector3 eye, Vector3 target, Vector3 up)\r\n        {\r\n            return Transform(vertex, Matrix4x4.CreateLookAt(eye, target, up));\r\n        }\r\n\r\n        public static Vector4 TransformToPerspectiveProjectionMatrix(Vector4 vertex, float fov, float aspect, \r\n            float zNear, float zFar)\r\n        {\r\n            var transformVertex = Transform(vertex, Matrix4x4.CreatePerspectiveFieldOfView(\r\n                fov, aspect, zFar, zNear));\r\n            return transformVertex;\r\n            return new Vector4(transformVertex.X / transformVertex.W, transformVertex.Y / transformVertex.W,\r\n                transformVertex.Z / transformVertex.W, transformVertex.W / transformVertex.W);\r\n        }\r\n\r\n        // Создает матрицу преобразования в пространство окна просмотра (viewport).\r\n        //width - Ширина окна просмотра\r\n        //height - Высота окна просмотра\r\n        //xmin - Минимальная координата X окна\r\n        //ymin - Минимальная координата Y окна\r\n        public static Vector4 TransformToViewportMatrix(Vector4 vertex, float width, float height, float xmin, float ymin)\r\n        {\r\n            return Transform(vertex, Matrix4x4.CreateViewport(0, 0, width, height, xmin, ymin));\r\n        }\r\n\r\n        public static Vector4 Transform(Vector4 vertex, Matrix4x4 matrix)\r\n        {\r\n            var vector4 = new Vector4(vertex.X, vertex.Y, vertex.Z, vertex.W);\r\n            var transformedV = Vector4.Transform(vector4, matrix);\r\n            return new(transformedV.X, transformedV.Y, transformedV.Z, transformedV.W);\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Realization/MatrixTransformations.cs b/Realization/MatrixTransformations.cs
--- a/Realization/MatrixTransformations.cs	(revision dc8ea09344de44f0ccb8d230f234d3119f4cf238)
+++ b/Realization/MatrixTransformations.cs	(date 1745507221158)
@@ -35,8 +35,9 @@
             var transformVertex = Transform(vertex, Matrix4x4.CreatePerspectiveFieldOfView(
                 fov, aspect, zFar, zNear));
             return transformVertex;
-            return new Vector4(transformVertex.X / transformVertex.W, transformVertex.Y / transformVertex.W,
-                transformVertex.Z / transformVertex.W, transformVertex.W / transformVertex.W);
+            return transformVertex;
+            /*return new Vector4(transformVertex.X / transformVertex.W, transformVertex.Y / transformVertex.W,
+                transformVertex.Z / transformVertex.W, transformVertex.W / transformVertex.W);*/
         }
 
         // Создает матрицу преобразования в пространство окна просмотра (viewport).
Index: Realization/ObjParaser.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using System.Globalization;\r\nusing System.Numerics;\r\nusing AKG.Realization.Elements;\r\n\r\nnamespace AKG.Realization\r\n{\r\n    public class ObjParser\r\n    {\r\n        public Model Parse(string filePath)\r\n        {\r\n            List<Vector4> Vertices = new List<Vector4>();\r\n            List<Vector3> TextureCoordinates = new List<Vector3>();\r\n            List<Normal> Normals = new List<Normal>();\r\n            List<Face> Faces = new List<Face>();\r\n\r\n            foreach (var line in File.ReadLines(filePath))\r\n            {\r\n                var parts = line.Split(' ', StringSplitOptions.RemoveEmptyEntries);\r\n                if (parts.Length == 0) continue;\r\n\r\n                switch (parts[0])\r\n                {\r\n                    case \"v\":\r\n                        Vertices.Add(new Vector4(\r\n                            float.Parse(parts[1], CultureInfo.InvariantCulture),\r\n                            float.Parse(parts[2], CultureInfo.InvariantCulture),\r\n                            float.Parse(parts[3], CultureInfo.InvariantCulture),\r\n                            parts.Length > 4 ? float.Parse(parts[4], CultureInfo.InvariantCulture) : 1.0f));\r\n                        break;\r\n\r\n                    case \"vt\":\r\n                        TextureCoordinates.Add(new Vector3(\r\n                            float.Parse(parts[1], CultureInfo.InvariantCulture),\r\n                            parts.Length > 2 ? float.Parse(parts[2], CultureInfo.InvariantCulture) : 0,\r\n                            parts.Length > 3 ? float.Parse(parts[3], CultureInfo.InvariantCulture) : 0));\r\n                        break;\r\n\r\n                    case \"vn\":\r\n                        Normals.Add(new Normal(\r\n                            float.Parse(parts[1], CultureInfo.InvariantCulture),\r\n                            float.Parse(parts[2], CultureInfo.InvariantCulture),\r\n                            float.Parse(parts[3], CultureInfo.InvariantCulture)));\r\n                        break;\r\n\r\n                    case \"f\":\r\n                        Faces.Add(new Face(parts[1..]));\r\n                        break;\r\n                }\r\n            }\r\n            return new Model(Vertices, TextureCoordinates, Normals, Faces);\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Realization/ObjParaser.cs b/Realization/ObjParaser.cs
--- a/Realization/ObjParaser.cs	(revision dc8ea09344de44f0ccb8d230f234d3119f4cf238)
+++ b/Realization/ObjParaser.cs	(date 1745507221169)
@@ -10,7 +10,7 @@
         {
             List<Vector4> Vertices = new List<Vector4>();
             List<Vector3> TextureCoordinates = new List<Vector3>();
-            List<Normal> Normals = new List<Normal>();
+            List<Vector3> Normals = new List<Vector3>();
             List<Face> Faces = new List<Face>();
 
             foreach (var line in File.ReadLines(filePath))
@@ -36,7 +36,7 @@
                         break;
 
                     case "vn":
-                        Normals.Add(new Normal(
+                        Normals.Add(new Vector3(
                             float.Parse(parts[1], CultureInfo.InvariantCulture),
                             float.Parse(parts[2], CultureInfo.InvariantCulture),
                             float.Parse(parts[3], CultureInfo.InvariantCulture)));
Index: Drawing/BuffBitmap.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using System;\r\nusing System.Collections.Generic;\r\nusing System.Drawing.Imaging;\r\nusing System.Linq;\r\nusing System.Runtime.InteropServices;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nusing static System.Drawing.Image;\r\n\r\n\r\nnamespace AKG.Drawing\r\n{\r\n    internal class BuffBitmap\r\n    {\r\n        private Bitmap _bitmap;\r\n        private byte[] _buffer;\r\n        private double[,] zBuffer;\r\n        private int depth;\r\n        public int width { get; set; }\r\n        public int height { get; set; }\r\n\r\n        public BuffBitmap(Bitmap bitmap)\r\n        {\r\n            _bitmap = bitmap;\r\n            width = _bitmap.Width;\r\n            height = _bitmap.Height;\r\n            zBuffer = new double[width, height];\r\n            for (int i = 0; i < height; i++)\r\n            {\r\n                for (int j = 0; j < width; j++)\r\n                {\r\n                    zBuffer[j, i] = int.MinValue;\r\n                }\r\n            }\r\n\r\n            depth = GetPixelFormatSize(bitmap.PixelFormat) / 8;\r\n            _buffer = new byte[width * height * depth];\r\n        }\r\n\r\n        public Color this[int x, int y]\r\n        {\r\n            get\r\n            {\r\n                var offset = (y * width + x) * depth;\r\n                return Color.FromArgb(_buffer[offset], _buffer[offset + 1], _buffer[offset + 2]);\r\n            }\r\n            set\r\n            {\r\n                if (x > 0 && x < width && y > 0 && y < height)\r\n                {\r\n                    var offset = (y * width + x) * depth;\r\n                    if (offset > _buffer.Length) return;\r\n                    _buffer[offset] = value.R;\r\n                    _buffer[offset + 1] = value.G;\r\n                    _buffer[offset + 2] = value.B;\r\n                    if (depth == 4)\r\n                    {\r\n                        _buffer[offset + 3] = 255;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        public bool PutZValue(int x, int y, double z)\r\n        {\r\n            double existedZ = zBuffer[x, y];\r\n            if (existedZ < z)\r\n            {\r\n                zBuffer[x, y] = z;\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        private void Reset()\r\n        {\r\n            Array.Fill<byte>(_buffer, 255);\r\n            for (int i = 0; i < height; i++)\r\n            for (int j = 0; j < width; j++)\r\n                zBuffer[j, i] = int.MinValue;\r\n        }\r\n\r\n        public void Flush() //переписать обратно в bitmap \r\n        {\r\n            var data = _bitmap.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.ReadWrite,\r\n                _bitmap.PixelFormat);\r\n            Marshal.Copy(_buffer, 0, data.Scan0, _buffer.Length);\r\n            _bitmap.UnlockBits(data);\r\n            _bitmap.Save(\"tmp.png\", ImageFormat.Png);\r\n            Reset();\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Drawing/BuffBitmap.cs b/Drawing/BuffBitmap.cs
--- a/Drawing/BuffBitmap.cs	(revision dc8ea09344de44f0ccb8d230f234d3119f4cf238)
+++ b/Drawing/BuffBitmap.cs	(date 1745507221180)
@@ -64,7 +64,7 @@
         public bool PutZValue(int x, int y, double z)
         {
             double existedZ = zBuffer[x, y];
-            if (existedZ < z)
+            if (existedZ <= z)
             {
                 zBuffer[x, y] = z;
                 return true;
Index: Drawing/Painter.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Numerics;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nusing AKG.Realization.Elements;\r\nusing static System.Math;\r\nusing static AKG.Realization.MatrixTransformations;\r\n\r\n\r\nnamespace AKG.Drawing\r\n{\r\n    internal class Painter\r\n    {\r\n        private BuffBitmap _buffer;\r\n        public int R { get; set; }\r\n        public int G { get; set; }\r\n        public int B { get; set; }\r\n\r\n        public Painter(Bitmap bitmap)\r\n        {\r\n            _buffer = new BuffBitmap(bitmap);\r\n        }\r\n\r\n\r\n        #region Первая лаба\r\n        private void DrawLine(int xStart, int yStart, int xEnd, int yEnd)\r\n        {\r\n            int dx = xEnd - xStart;\r\n            int dy = yEnd - yStart;\r\n\r\n            // Определение сторон сдвига\r\n            int incx = Sign(dx); // -1 для справа налево и +1 для слеванаправо\r\n            int incy = Sign(dy); // -1 для снизу вверх и +1 для сверху вниз\r\n\r\n            // Получение абсолютных длин проекций\r\n            dx = Abs(dx);\r\n            dy = Abs(dy);\r\n\r\n            int x;\r\n            int y;\r\n            int pdx;\r\n            int pdy;\r\n            int es;\r\n            int el;\r\n            int err;\r\n\r\n            // Определение направления прохода в цикле в зависимости от вытянутости\r\n            if (dx > dy)\r\n            {\r\n                // Отрезок более длинный, чем высокий\r\n                pdx = incx;\r\n                pdy = 0;\r\n\r\n                es = dy;\r\n                el = dx;\r\n            }\r\n            else\r\n            {\r\n                // Отрезок более высокий, чем длинный\r\n                pdx = 0;\r\n                pdy = incy;\r\n\r\n                es = dx;\r\n                el = dy;\r\n            }\r\n\r\n            x = xStart;\r\n            y = yStart;\r\n            err = el / 2;\r\n\r\n\r\n            // Цикл растеризации\r\n            _buffer[x, y] = Color.Black;\r\n            for (int i = 0; i < el; i++)\r\n            {\r\n                err -= es;\r\n                if (err < 0)\r\n                {\r\n                    err += el;\r\n\r\n                    // Cдвинуть прямую (сместить вверх или вниз, если цикл проходит по иксам\r\n                    // или сместить влево-вправо, если цикл проходит по y)\r\n                    x += incx;\r\n                    y += incy;\r\n                }\r\n                else\r\n                {\r\n                    // Продолжить тянуть прямую дальше (сдвинуть влево или вправо, если\r\n                    // цикл идёт по иксу; сдвинуть вверх или вниз, если по y)\r\n                    x += pdx;\r\n                    y += pdy;\r\n                }\r\n\r\n                _buffer[x, y] = Color.Black;\r\n            }\r\n        }\r\n\r\n        public void PaintModelLaba1(Model model)\r\n        {\r\n            model.CalculateVertices(_buffer.width, _buffer.height);\r\n\r\n            //переводим\r\n            //рисуем в буфер\r\n            Parallel.ForEach(model.GetModelFaces(), face =>\r\n            {\r\n                var v0 = model.GetViewPortVertices()[face.Indices[0].VertexIndex - 1];\r\n                var v1 = model.GetViewPortVertices()[face.Indices[1].VertexIndex - 1];\r\n                var v2 = model.GetViewPortVertices()[face.Indices[2].VertexIndex - 1];\r\n\r\n                DrawLine((int)v0.X, (int)v0.Y, (int)v1.X, (int)v1.Y);\r\n                DrawLine((int)v0.X, (int)v0.Y, (int)v2.X, (int)v2.Y);\r\n                DrawLine((int)v2.X, (int)v2.Y, (int)v1.X, (int)v1.Y);\r\n            });\r\n            //пишем из буфера\r\n            _buffer.Flush();\r\n        }\r\n        #endregion\r\n\r\n\r\n        #region Вторая лаба\r\n        private void DrawTriangle(Vector4 v0, Vector4 v1, Vector4 v2, Color color)\r\n        {\r\n            // Сортировка вершин по Y (v0.Y <= v1.Y <= v2.Y)\r\n            if (v0.Y > v2.Y) (v0, v2) = (v2, v0);\r\n            if (v0.Y > v1.Y) (v0, v1) = (v1, v0);\r\n            if (v1.Y > v2.Y) (v1, v2) = (v2, v1);\r\n\r\n            // Вычисление градиентов (приращения X на единицу Y)\r\n            var kv1 = (v2 - v0) / (v2.Y - v0.Y);\r\n            var kv2 = (v1 - v0) / (v1.Y - v0.Y);\r\n            var kv3 = (v2 - v1) / (v2.Y - v1.Y);\r\n\r\n            // Значения z-буффера для вершин треугольника\r\n            var kz1 = (v2.Z - v0.Z) / (v2.Y - v0.Y);\r\n            var kz2 = (v1.Z - v0.Z) / (v1.Y - v0.Y);\r\n            var kz3 = (v2.Z - v1.Z) / (v2.Y - v1.Y);\r\n\r\n            // Границы по Y\r\n            var top = Math.Max(0, (int)Math.Ceiling(v0.Y));\r\n            var bottom = Math.Min(_buffer.height, (int)Math.Ceiling(v2.Y));\r\n\r\n            // Цикл по строкам\r\n            for (int y = top; y < bottom; y++)\r\n            {\r\n                // Определяем крайние точки\r\n                var av = v0 + (y - v0.Y) * kv1;\r\n                var bv = (y < v1.Y) ? v0 + (y - v0.Y) * kv2 : v1 + (y - v1.Y) * kv3;\r\n\r\n                // Значения z-буффера для крайних точек\r\n                var az = v0.Z + (y - v0.Y) * kz1;\r\n                var bz = y < v1.Y ? v0.Z + (y - v0.Y) * kz2 : v1.Z + (y - v1.Y) * kz3;\r\n\r\n                // Упорядочиваем крайние точки\r\n                if (av.X > bv.X) (av, bv) = (bv, av);\r\n                if (av.X > bv.X) (az, bz) = (bz, az);\r\n\r\n                // Рисуем горизонтальную линию от av.X до bv.X\r\n                var left = Math.Max(0, (int)Math.Ceiling(av.X));\r\n                var right = Math.Min(_buffer.width, (int)Math.Ceiling(bv.X));\r\n\r\n                // Цикл по абсциссам\r\n                var kz = (bz - az) / (bv.X - av.X);\r\n                for (int x = left; x < right; x++)\r\n                {\r\n                    var z = az + (x - av.X) * kz;\r\n                    if (_buffer.PutZValue(x, y, z))\r\n                        _buffer[x, y] = color;\r\n                }\r\n            }\r\n        }\r\n\r\n        public void PaintModelLaba2(Model model)\r\n        {\r\n            model.CalculateVertices(_buffer.width, _buffer.height);\r\n\r\n            //переводим\r\n            //рисуем в буфер\r\n\r\n            foreach (var face in model.GetModelFaces())\r\n            {\r\n                var v0 = model.GetViewPortVertices()[face.Indices[0].VertexIndex - 1];\r\n                var v1 = model.GetViewPortVertices()[face.Indices[1].VertexIndex - 1];\r\n                var v2 = model.GetViewPortVertices()[face.Indices[2].VertexIndex - 1];\r\n\r\n                // Вычисляем два ребра треугольника\r\n                var edge1 = v1 - v0;\r\n                var edge2 = v2 - v0;\r\n\r\n                // Вычисляем нормаль через векторное произведение\r\n                var normal = Vector3.Cross(\r\n                    new Vector3(edge1.X, edge1.Y, edge1.Z),\r\n                    new Vector3(edge2.X, edge2.Y, edge2.Z));\r\n                normal = Vector3.Normalize(normal);\r\n\r\n                // Проверяем, смотрит ли нормаль в сторону наблюдателя\r\n                if (Vector3.Dot(normal, model.target) > 0)\r\n                {\r\n                    // Вычисляем освещенность по Ламберту\r\n                    var vl0 = model.GetWorldVertices()[face.Indices[0].VertexIndex - 1];\r\n                    var vl1 = model.GetWorldVertices()[face.Indices[1].VertexIndex - 1];\r\n                    var vl2 = model.GetWorldVertices()[face.Indices[2].VertexIndex - 1];\r\n\r\n                    var lightEdge1 = vl1 - vl0;\r\n                    var lightEdge2 = vl2 - vl0;\r\n\r\n                    var lightNormal = Vector3.Normalize(Vector3.Cross(\r\n                        new Vector3(lightEdge1.X, lightEdge1.Y, lightEdge1.Z),\r\n                        new Vector3(lightEdge2.X, lightEdge2.Y, lightEdge2.Z)));\r\n                    float intensity = Vector3.Dot(lightNormal, -model.lightDir);\r\n\r\n                    // Определяем цвет треугольника (оттенки синего)\r\n                    int colorValue = (int)(255 * intensity);\r\n                    colorValue = Math.Clamp(colorValue, 0, 255); // Ограничиваем 0-255\r\n                    int r = (int)(this.R * colorValue / 255);\r\n                    int g = (int)(this.G * colorValue / 255);\r\n                    int b = (int)(this.B * colorValue / 255);\r\n                    //Color shadedColor = Color.FromArgb(255, colorValue, colorValue, colorValue); // Голубой с вариациями\r\n                    Color shadedColor = Color.FromArgb(255, b, g, r); // Голубой с вариациями\r\n\r\n                    DrawTriangle(\r\n                        new Vector4(v0.X, v0.Y, vl0.Z, v0.W),\r\n                        new Vector4(v1.X, v1.Y, vl1.Z, v1.W),\r\n                        new Vector4(v2.X, v2.Y, vl2.Z, v2.W),\r\n                        shadedColor);\r\n                }\r\n            }\r\n\r\n            //пишем из буфера\r\n            _buffer.Flush();\r\n        }\r\n        #endregion\r\n\r\n\r\n        #region Третья лаба\r\n        private void DrawTriangleWithPhongInterpolation(\r\n    Vector4 v0, Vector4 v1, Vector4 v2,\r\n    Vector3 n0, Vector3 n1, Vector3 n2,\r\n    Vector3 worldPos0, Vector3 worldPos1, Vector3 worldPos2,\r\n    Vector3 Ka, Vector3 Kd, Vector3 Ks, float shininess, Vector3 lightDir, Vector3 viewDir, Vector3 lightColor)\r\n        {\r\n            // Сортировка вершин по Y (v0.Y <= v1.Y <= v2.Y)\r\n            if (v0.Y > v2.Y) { (v0, v2) = (v2, v0); (n0, n2) = (n2, n0); (worldPos0, worldPos2) = (worldPos2, worldPos0); }\r\n            if (v0.Y > v1.Y) { (v0, v1) = (v1, v0); (n0, n1) = (n1, n0); (worldPos0, worldPos1) = (worldPos1, worldPos0); }\r\n            if (v1.Y > v2.Y) { (v1, v2) = (v2, v1); (n1, n2) = (n2, n1); (worldPos1, worldPos2) = (worldPos2, worldPos1); }\r\n\r\n            // Вычисление градиентов для координат X, Z и нормалей\r\n            var kv1 = (v2 - v0) / (v2.Y - v0.Y);\r\n            var kv2 = (v1 - v0) / (v1.Y - v0.Y);\r\n            var kv3 = (v2 - v1) / (v2.Y - v1.Y);\r\n\r\n            var kz1 = (v2.Z - v0.Z) / (v2.Y - v0.Y);\r\n            var kz2 = (v1.Z - v0.Z) / (v1.Y - v0.Y);\r\n            var kz3 = (v2.Z - v1.Z) / (v2.Y - v1.Y);\r\n\r\n            // Градиенты для нормалей\r\n            var kn1 = (n2 - n0) / (v2.Y - v0.Y);\r\n            var kn2 = (n1 - n0) / (v1.Y - v0.Y);\r\n            var kn3 = (n2 - n1) / (v2.Y - v1.Y);\r\n\r\n            // Градиенты для мировых позиций (для перспективно-корректной интерполяции)\r\n            var kwp1 = (worldPos2 - worldPos0) / (v2.Y - v0.Y);\r\n            var kwp2 = (worldPos1 - worldPos0) / (v1.Y - v0.Y);\r\n            var kwp3 = (worldPos2 - worldPos1) / (v2.Y - v1.Y);\r\n\r\n            // Границы по Y\r\n            var top = Math.Max(0, (int)Math.Ceiling(v0.Y));\r\n            var bottom = Math.Min(_buffer.height, (int)Math.Ceiling(v2.Y));\r\n\r\n            // Цикл по строкам\r\n            for (int y = top; y < bottom; y++)\r\n            {\r\n                // Определяем крайние точки\r\n                var av = v0 + (y - v0.Y) * kv1;\r\n                var bv = (y < v1.Y) ? v0 + (y - v0.Y) * kv2 : v1 + (y - v1.Y) * kv3;\r\n\r\n                // Значения z-буффера для крайних точек\r\n                var az = v0.Z + (y - v0.Y) * kz1;\r\n                var bz = y < v1.Y ? v0.Z + (y - v0.Y) * kz2 : v1.Z + (y - v1.Y) * kz3;\r\n\r\n                // Нормали для крайних точек\r\n                Vector3 aNormal = n0 + (y - v0.Y) * kn1;\r\n                Vector3 bNormal = y < v1.Y ? n0 + (y - v0.Y) * kn2 : n1 + (y - v1.Y) * kn3;\r\n\r\n                // Мировые позиции для крайних точек\r\n                Vector3 aWorldPos = worldPos0 + (y - v0.Y) * kwp1;\r\n                Vector3 bWorldPos = y < v1.Y ? worldPos0 + (y - v0.Y) * kwp2 : worldPos1 + (y - v1.Y) * kwp3;\r\n\r\n                // Упорядочиваем крайние точки\r\n                if (av.X > bv.X)\r\n                {\r\n                    (av, bv) = (bv, av);\r\n                    (az, bz) = (bz, az);\r\n                    (aNormal, bNormal) = (bNormal, aNormal);\r\n                    (aWorldPos, bWorldPos) = (bWorldPos, aWorldPos);\r\n                }\r\n\r\n                // Рисуем горизонтальную линию от av.X до bv.X\r\n                var left = Math.Max(0, (int)Math.Ceiling(av.X));\r\n                var right = Math.Min(_buffer.width, (int)Math.Ceiling(bv.X));\r\n\r\n                // Коэффициенты для интерполяции по X\r\n                var kz = (bv.X != av.X) ? (bz - az) / (bv.X - av.X) : 0;\r\n                var kNormal = (bv.X != av.X) ? (bNormal - aNormal) / (bv.X - av.X) : Vector3.Zero;\r\n                var kWorldPos = (bv.X != av.X) ? (bWorldPos - aWorldPos) / (bv.X - av.X) : Vector3.Zero;\r\n\r\n                for (int x = left; x < right; x++)\r\n                {\r\n                    var z = az + (x - av.X) * kz;\r\n                    Vector3 pixelNormal = Vector3.Normalize(aNormal + (x - av.X) * kNormal);\r\n                    Vector3 pixelWorldPos = aWorldPos + (x - av.X) * kWorldPos;\r\n\r\n                    // Вычисляем цвет по Фонгу для каждого пикселя\r\n                    Color pixelColor = CalculatePhongColor(\r\n                        new Vector4(pixelWorldPos, 1),\r\n                        pixelNormal,\r\n                        lightDir,\r\n                        viewDir,\r\n                        Ka, Kd, Ks, shininess, lightColor);\r\n\r\n                    if (_buffer.PutZValue(x, y, z))\r\n                        _buffer[x, y] = pixelColor;\r\n                }\r\n            }\r\n        }\r\n\r\n        public void PaintModelLaba3(Model model)\r\n        {\r\n            model.CalculateVertices(_buffer.width, _buffer.height);\r\n\r\n            var modelNormals = model.GetNormals();\r\n            foreach (var face in model.GetModelFaces())\r\n            {\r\n                var v0 = model.GetViewPortVertices()[face.Indices[0].VertexIndex - 1];\r\n                var v1 = model.GetViewPortVertices()[face.Indices[1].VertexIndex - 1];\r\n                var v2 = model.GetViewPortVertices()[face.Indices[2].VertexIndex - 1];\r\n\r\n                // Вычисляем нормаль треугольника (для backface culling)\r\n                var edge1 = v1 - v0;\r\n                var edge2 = v2 - v0;\r\n                var normal = Vector3.Normalize(Vector3.Cross(\r\n                    new Vector3(edge1.X, edge1.Y, edge1.Z),\r\n                    new Vector3(edge2.X, edge2.Y, edge2.Z)));\r\n\r\n                if (Vector3.Dot(normal, model.target) > 0)\r\n                {\r\n                    // Мировые координаты вершин\r\n                    var wv0 = model.GetWorldVertices()[face.Indices[0].VertexIndex - 1];\r\n                    var wv1 = model.GetWorldVertices()[face.Indices[1].VertexIndex - 1];\r\n                    var wv2 = model.GetWorldVertices()[face.Indices[2].VertexIndex - 1];\r\n\r\n                    var n0 = modelNormals[face.Indices[0].VertexIndex - 1];\r\n                    var n1 = modelNormals[face.Indices[1].VertexIndex - 1];\r\n                    var n2 = modelNormals[face.Indices[2].VertexIndex - 1];\r\n\r\n                    // Рисуем треугольник с интерполяцией нормалей (Phong shading)\r\n                    DrawTriangleWithPhongInterpolation(\r\n                        new Vector4(v0.X, v0.Y, wv0.Z, v0.W),\r\n                        new Vector4(v1.X, v1.Y, wv1.Z, v1.W),\r\n                        new Vector4(v2.X, v2.Y, wv2.Z, v2.W),\r\n                        n0, n1, n2,\r\n                        new Vector3(wv0.X, wv0.Y, wv0.Z),\r\n                        new Vector3(wv1.X, wv1.Y, wv1.Z),\r\n                        new Vector3(wv2.X, wv2.Y, wv2.Z),\r\n                        model.Ka, model.Kd, model.Ks, model.Shininess,\r\n                        model.lightDir, model.target, model.lightColor);\r\n                }\r\n            }\r\n\r\n            _buffer.Flush();\r\n        }\r\n        private void DrawTriangleWithInterpolation(Vector4 v0, Vector4 v1, Vector4 v2, Color c0, Color c1, Color c2)\r\n        {\r\n            // Сортировка вершин по Y (v0.Y <= v1.Y <= v2.Y)\r\n            if (v0.Y > v2.Y)\r\n            {\r\n                (v0, v2) = (v2, v0);\r\n                (c0, c2) = (c2, c0);\r\n            }\r\n\r\n            if (v0.Y > v1.Y)\r\n            {\r\n                (v0, v1) = (v1, v0);\r\n                (c0, c1) = (c1, c0);\r\n            }\r\n\r\n            if (v1.Y > v2.Y)\r\n            {\r\n                (v1, v2) = (v2, v1);\r\n                (c1, c2) = (c2, c1);\r\n            }\r\n\r\n            // Вычисление градиентов для координат X и Z\r\n            var kv1 = (v2 - v0) / (v2.Y - v0.Y);\r\n            var kv2 = (v1 - v0) / (v1.Y - v0.Y);\r\n            var kv3 = (v2 - v1) / (v2.Y - v1.Y);\r\n\r\n            var kz1 = (v2.Z - v0.Z) / (v2.Y - v0.Y);\r\n            var kz2 = (v1.Z - v0.Z) / (v1.Y - v0.Y);\r\n            var kz3 = (v2.Z - v1.Z) / (v2.Y - v1.Y);\r\n\r\n            // Границы по Y\r\n            var top = Math.Max(0, (int)Math.Ceiling(v0.Y));\r\n            var bottom = Math.Min(_buffer.height, (int)Math.Ceiling(v2.Y));\r\n\r\n            // Цикл по строкам\r\n            for (int y = top; y < bottom; y++)\r\n            {\r\n                // Определяем крайние точки\r\n                var av = v0 + (y - v0.Y) * kv1;\r\n                var bv = (y < v1.Y) ? v0 + (y - v0.Y) * kv2 : v1 + (y - v1.Y) * kv3;\r\n\r\n                // Значения z-буффера для крайних точек\r\n                var az = v0.Z + (y - v0.Y) * kz1;\r\n                var bz = y < v1.Y ? v0.Z + (y - v0.Y) * kz2 : v1.Z + (y - v1.Y) * kz3;\r\n\r\n                // Цвета для крайних точек (интерполяция по Y)\r\n                Color aColor, bColor;\r\n                if (y < v1.Y)\r\n                {\r\n                    float t = (y - v0.Y) / (v1.Y - v0.Y);\r\n                    aColor = InterpolateColor(c0, c2, (y - v0.Y) / (v2.Y - v0.Y));\r\n                    bColor = InterpolateColor(c0, c1, t);\r\n                }\r\n                else\r\n                {\r\n                    float t = (y - v1.Y) / (v2.Y - v1.Y);\r\n                    aColor = InterpolateColor(c0, c2, (y - v0.Y) / (v2.Y - v0.Y));\r\n                    bColor = InterpolateColor(c1, c2, t);\r\n                }\r\n\r\n                // Упорядочиваем крайние точки\r\n                if (av.X > bv.X)\r\n                {\r\n                    (av, bv) = (bv, av);\r\n                    (az, bz) = (bz, az);\r\n                    (aColor, bColor) = (bColor, aColor);\r\n                }\r\n\r\n                // Рисуем горизонтальную линию от av.X до bv.X\r\n                var left = Math.Max(0, (int)Math.Ceiling(av.X));\r\n                var right = Math.Min(_buffer.width, (int)Math.Ceiling(bv.X));\r\n\r\n                // Цикл по абсциссам\r\n                var kz = (bv.X != av.X) ? (bz - az) / (bv.X - av.X) : 0;\r\n                var kColor = (bv.X != av.X) ? 1.0f / (bv.X - av.X) : 0;\r\n\r\n                for (int x = left; x < right; x++)\r\n                {\r\n                    var z = az + (x - av.X) * kz;\r\n                    float tColor = (x - av.X) * kColor;\r\n                    Color pixelColor = InterpolateColor(aColor, bColor, tColor);\r\n\r\n                    if (_buffer.PutZValue(x, y, z))\r\n                        _buffer[x, y] = pixelColor;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Вспомогательная функция для интерполяции цвета\r\n        private Color InterpolateColor(Color x, Color y, float t)\r\n        {\r\n            t = Math.Clamp(t, 0, 1);\r\n            int r = (int)(x.R + (y.R - x.R) * t);\r\n            int g = (int)(x.G + (y.G - x.G) * t);\r\n            int b = (int)(x.B + (y.B - x.B) * t);\r\n            return Color.FromArgb(r, g, b);\r\n        }\r\n\r\n        private Color CalculatePhongColor(Vector4 position4, Vector3 normal, Vector3 lightDir, Vector3 viewDir,\r\n            Vector3 Ka, Vector3 Kd, Vector3 Ks, float shininess, Vector3 lightColor)\r\n        {\r\n            var position = new Vector3(position4.X, position4.Y, position4.Z);\r\n            normal = Vector3.Normalize(normal);\r\n            lightDir = Vector3.Normalize(-lightDir);\r\n            viewDir = Vector3.Normalize(viewDir - position);\r\n\r\n            // Фоновое освещение\r\n            Vector3 ambient = Ka * lightColor * 1f;\r\n            // Рассеянное освещение\r\n            float diff = Math.Max(Vector3.Dot(normal, lightDir), 0);\r\n            Vector3 diffuse = Kd * diff * lightColor;   \r\n            // Зеркальное освещение\r\n            Vector3 reflectDir = Vector3.Reflect(-lightDir, normal);\r\n            float spec = (float)Math.Pow(Math.Max(Vector3.Dot(viewDir, reflectDir), 0), shininess);\r\n            Vector3 specular = Ks * spec * lightColor;\r\n            // Суммируем компоненты\r\n            Vector3 finalColor = ambient + diffuse + specular;\r\n\r\n            // Преобразуем в Color (ограничиваем значения 0-1)\r\n            finalColor = Vector3.Clamp(finalColor, Vector3.Zero, Vector3.One);\r\n            return Color.FromArgb(\r\n                (int)(finalColor.X * this.B),\r\n                (int)(finalColor.Y * this.G),\r\n                (int)(finalColor.Z * this.R));\r\n        }\r\n        #endregion\r\n\r\n        /*#region asdasdsadadas\r\n        public void PaintModelLaba4(Model model)\r\n        {\r\n            // Вычисляем вершины модели в мировом пространстве\r\n            model.CalculateVertices(_buffer.width, _buffer.height);\r\n\r\n            // Получаем текстурные координаты\r\n            var textureCoords = model.GetTextureCoords();\r\n            var Normalstmp = model.GetNormals();\r\n            var viewPortVertices = model.GetViewPortVertices();\r\n            var worldVertices = model.GetWorldVertices();\r\n            // Перебираем все грани модели\r\n            foreach (var face in model.GetModelFaces())\r\n            {\r\n                // Вершины треугольника в пространстве экрана\r\n                var v0 = viewPortVertices[face.Indices[0].VertexIndex - 1];\r\n                var v1 = viewPortVertices[face.Indices[1].VertexIndex - 1];\r\n                var v2 = viewPortVertices[face.Indices[2].VertexIndex - 1];\r\n\r\n                // Текстурные координаты вершин\r\n                var uv0 = textureCoords[face.Indices[0].TextureIndex - 1];\r\n                var uv1 = textureCoords[face.Indices[1].TextureIndex - 1];\r\n                var uv2 = textureCoords[face.Indices[2].TextureIndex - 1];\r\n\r\n                // Мировые координаты вершин\r\n                var wv0 = worldVertices[face.Indices[0].VertexIndex - 1];\r\n                var wv1 = worldVertices[face.Indices[1].VertexIndex - 1];\r\n                var wv2 = worldVertices[face.Indices[2].VertexIndex - 1];\r\n\r\n                // Нормали вершин\r\n                var n0 = Normalstmp[face.Indices[0].VertexIndex - 1];\r\n                var n1 = Normalstmp[face.Indices[1].VertexIndex - 1];\r\n                var n2 = Normalstmp[face.Indices[2].VertexIndex - 1];\r\n\r\n                // Рисуем треугольник с текстурированием\r\n                DrawTexturedTriangle(\r\n                    new Vector4(v0.X, v0.Y, wv0.Z, v0.W),\r\n                    new Vector4(v1.X, v1.Y, wv1.Z, v1.W),\r\n                    new Vector4(v2.X, v2.Y, wv2.Z, v2.W),\r\n                    uv0, uv1, uv2,\r\n                    n0, n1, n2,\r\n                    model.DiffuseMap, model.NormalMap, model.SpecularMap,\r\n                    model.Ka, model.Kd, model.Ks, model.Shininess,\r\n                    model.lightDir, model.target, model.lightColor);\r\n            }\r\n\r\n            // Пишем из буфера на экран\r\n            _buffer.Flush();\r\n        }\r\n\r\n        private void DrawTexturedTriangle(\r\n            Vector4 v0, Vector4 v1, Vector4 v2,\r\n            Vector2 uv0, Vector2 uv1, Vector2 uv2,\r\n            Vector3 n0, Vector3 n1, Vector3 n2,\r\n            Bitmap diffuseMap, Bitmap normalMap, Bitmap specularMap,\r\n            Vector3 Ka, Vector3 Kd, Vector3 Ks, float shininess,\r\n            Vector3 lightDir, Vector3 viewDir, Vector3 lightColor)\r\n        {\r\n            // Сортировка вершин по Y (v0.Y <= v1.Y <= v2.Y)\r\n            if (v0.Y > v2.Y) { (v0, v2) = (v2, v0); (uv0, uv2) = (uv2, uv0); (n0, n2) = (n2, n0); }\r\n            if (v0.Y > v1.Y) { (v0, v1) = (v1, v0); (uv0, uv1) = (uv1, uv0); (n0, n1) = (n1, n0); }\r\n            if (v1.Y > v2.Y) { (v1, v2) = (v2, v1); (uv1, uv2) = (uv2, uv1); (n1, n2) = (n2, n1); }\r\n\r\n            // Вычисление градиентов для координат X, Z, текстурных координат и нормалей\r\n            var kv1 = (v2 - v0) / (v2.Y - v0.Y);\r\n            var kv2 = (v1 - v0) / (v1.Y - v0.Y);\r\n            var kv3 = (v2 - v1) / (v2.Y - v1.Y);\r\n            var kz1 = (v2.Z - v0.Z) / (v2.Y - v0.Y);\r\n            var kz2 = (v1.Z - v0.Z) / (v1.Y - v0.Y);\r\n            var kz3 = (v2.Z - v1.Z) / (v2.Y - v1.Y);\r\n            var kuv1 = (uv2 - uv0) / (v2.Y - v0.Y);\r\n            var kuv2 = (uv1 - uv0) / (v1.Y - v0.Y);\r\n            var kuv3 = (uv2 - uv1) / (v2.Y - v1.Y);\r\n            var kn1 = (n2 - n0) / (v2.Y - v0.Y);\r\n            var kn2 = (n1 - n0) / (v1.Y - v0.Y);\r\n            var kn3 = (n2 - n1) / (v2.Y - v1.Y);\r\n\r\n            // Границы по Y\r\n            var top = Math.Max(0, (int)Math.Ceiling(v0.Y));\r\n            var bottom = Math.Min(_buffer.height, (int)Math.Ceiling(v2.Y));\r\n\r\n            // Цикл по строкам\r\n            for (int y = top; y < bottom; y++)\r\n            {\r\n                // Определяем крайние точки\r\n                var av = v0 + (y - v0.Y) * kv1;\r\n                var bv = (y < v1.Y) ? v0 + (y - v0.Y) * kv2 : v1 + (y - v1.Y) * kv3;\r\n\r\n                // Значения z-буффера для крайних точек\r\n                var az = v0.Z + (y - v0.Y) * kz1;\r\n                var bz = y < v1.Y ? v0.Z + (y - v0.Y) * kz2 : v1.Z + (y - v1.Y) * kz3;\r\n\r\n                // Текстурные координаты для крайних точек\r\n                var auv = uv0 + (y - v0.Y) * kuv1;\r\n                var buv = y < v1.Y ? uv0 + (y - v0.Y) * kuv2 : uv1 + (y - v1.Y) * kuv3;\r\n\r\n                // Нормали для крайних точек\r\n                var aNormal = n0 + (y - v0.Y) * kn1;\r\n                var bNormal = y < v1.Y ? n0 + (y - v0.Y) * kn2 : n1 + (y - v1.Y) * kn3;\r\n\r\n                // Упорядочиваем крайние точки\r\n                if (av.X > bv.X)\r\n                {\r\n                    (av, bv) = (bv, av);\r\n                    (az, bz) = (bz, az);\r\n                    (auv, buv) = (buv, auv);\r\n                    (aNormal, bNormal) = (bNormal, aNormal);\r\n                }\r\n\r\n                // Рисуем горизонтальную линию от av.X до bv.X\r\n                var left = Math.Max(0, (int)Math.Ceiling(av.X));\r\n                var right = Math.Min(_buffer.width, (int)Math.Ceiling(bv.X));\r\n\r\n                // Цикл по абсциссам\r\n                var kz = (bv.X != av.X) ? (bz - az) / (bv.X - av.X) : 0;\r\n                var kuv = (bv.X != av.X) ? (buv - auv) / (bv.X - av.X) : Vector2.Zero;\r\n                var kNormal = (bv.X != av.X) ? (bNormal - aNormal) / (bv.X - av.X) : Vector3.Zero;\r\n\r\n                for (int x = left; x < right; x++)\r\n                {\r\n                    var z = az + (x - av.X) * kz;\r\n                    var uv = auv + (x - av.X) * kuv;\r\n                    var pixelNormal = Vector3.Normalize(aNormal + (x - av.X) * kNormal);\r\n\r\n                    // Получаем цвет из текстур\r\n                    //Color diffuseColor = SampleTexture(diffuseMap, uv);\r\n                    Color diffuseColor = (Color.Brown);\r\n                    Color normalColor = SampleTexture(normalMap, uv);\r\n                    Color specularColor = SampleTexture(specularMap, uv);\r\n\r\n                    // Преобразуем цвет нормали в вектор\r\n                    Vector3 normalFromMap = new Vector3(\r\n                        normalColor.R / 255f * 2 - 1,\r\n                        normalColor.G / 255f * 2 - 1,\r\n                        normalColor.B / 255f * 2 - 1);\r\n\r\n                    // Вычисляем освещение по Фонгу\r\n                    Color pixelColor = CalculatePhongColorWithTextures(\r\n                        new Vector4(x, y, z, 1),\r\n                        pixelNormal, normalFromMap,\r\n                        lightDir, viewDir,\r\n                        Ka, Kd, Ks, shininess, lightColor,\r\n                        diffuseColor, specularColor);\r\n\r\n                    // Пишем пиксель в буфер\r\n                    if (_buffer.PutZValue(x, y, z))\r\n                        _buffer[x, y] = pixelColor;\r\n                }\r\n            }\r\n        }\r\n\r\n        private Color SampleTexture(Bitmap texture, Vector2 uv)\r\n        {\r\n            int x = (int)(uv.X * texture.Width) % texture.Width;\r\n            int y = (int)(uv.Y * texture.Height) % texture.Height;\r\n            return texture.GetPixel(x, y);\r\n        }\r\n\r\n        private Color CalculatePhongColorWithTextures(\r\n            Vector4 position4, Vector3 normal, Vector3 normalFromMap,\r\n            Vector3 lightDir, Vector3 viewDir,\r\n            Vector3 Ka, Vector3 Kd, Vector3 Ks, float shininess, Vector3 lightColor,\r\n            Color diffuseColor, Color specularColor)\r\n        {\r\n            var position = new Vector3(position4.X, position4.Y, position4.Z);\r\n            normal = Vector3.Normalize(normal);\r\n            normalFromMap = Vector3.Normalize(normalFromMap);\r\n            lightDir = Vector3.Normalize(-lightDir);\r\n            viewDir = Vector3.Normalize(viewDir - position);\r\n\r\n            // Фоновое освещение\r\n            Vector3 ambient = Ka * lightColor * 1f;\r\n\r\n            // Рассеянное освещение\r\n            float diff = Math.Max(Vector3.Dot(normalFromMap, lightDir), 0);\r\n            Vector3 diffuse = new Vector3(diffuseColor.R / 255f, diffuseColor.G / 255f, diffuseColor.B / 255f) * diff * lightColor;\r\n\r\n            // Зеркальное освещение\r\n            Vector3 reflectDir = Vector3.Reflect(-lightDir, normalFromMap);\r\n            float spec = (float)Math.Pow(Math.Max(Vector3.Dot(viewDir, reflectDir), 0), shininess);\r\n            Vector3 specular = new Vector3(specularColor.R / 255f, specularColor.G / 255f, specularColor.B / 255f) * spec * lightColor;\r\n\r\n            // Суммируем компоненты\r\n            Vector3 finalColor = ambient + diffuse + specular;\r\n\r\n            // Преобразуем в Color (ограничиваем значения 0-1)\r\n            finalColor = Vector3.Clamp(finalColor, Vector3.Zero, Vector3.One);\r\n            return Color.FromArgb(\r\n                (int)(finalColor.X * 255),\r\n                (int)(finalColor.Y * 255),\r\n                (int)(finalColor.Z * 255));\r\n        }\r\n        #endregion*/\r\n\r\n\r\n        /*#region try 3\r\n        public void PaintModelLaba4(Model model)\r\n        {\r\n            model.CalculateVertices(_buffer.width, _buffer.height);\r\n            var modelUVs = model.GetModelTextureCoordinates();\r\n\r\n            foreach (var face in model.GetModelFaces())\r\n            {\r\n                var v0 = model.GetViewPortVertices()[face.Indices[0].VertexIndex - 1];\r\n                var v1 = model.GetViewPortVertices()[face.Indices[1].VertexIndex - 1];\r\n                var v2 = model.GetViewPortVertices()[face.Indices[2].VertexIndex - 1];\r\n\r\n                // Backface culling\r\n                var edge1 = v1 - v0;\r\n                var edge2 = v2 - v0;\r\n                var normal = Vector3.Normalize(Vector3.Cross(\r\n                    new Vector3(edge1.X, edge1.Y, edge1.Z),\r\n                    new Vector3(edge2.X, edge2.Y, edge2.Z)));\r\n\r\n                if (Vector3.Dot(normal, model.target) > 0)\r\n                {\r\n                    var wv0 = model.GetWorldVertices()[face.Indices[0].VertexIndex - 1];\r\n                    var wv1 = model.GetWorldVertices()[face.Indices[1].VertexIndex - 1];\r\n                    var wv2 = model.GetWorldVertices()[face.Indices[2].VertexIndex - 1];\r\n\r\n                    var uv0 = modelUVs[face.Indices[0].TextureIndex - 1];\r\n                    var uv1 = modelUVs[face.Indices[1].TextureIndex - 1];\r\n                    var uv2 = modelUVs[face.Indices[2].TextureIndex - 1];\r\n\r\n                    DrawTexturedTriangle(\r\n                        new Vector4(v0.X, v0.Y, wv0.Z, v0.W),\r\n                        new Vector4(v1.X, v1.Y, wv1.Z, v1.W),\r\n                        new Vector4(v2.X, v2.Y, wv2.Z, v2.W),\r\n                        uv0, uv1, uv2,\r\n                        model);\r\n                }\r\n            }\r\n            _buffer.Flush();\r\n        }\r\n\r\n        private void DrawTexturedTriangle(Vector4 v0, Vector4 v1, Vector4 v2,\r\n            Vector3 uv0, Vector3 uv1, Vector3 uv2,\r\n            Model model)\r\n        {\r\n            if (v0.Y < 0 || v1.Y < 0 || v2.Y < 0) return; // Пропускаем треугольники вне экрана\r\n            // Сортировка вершин по Y\r\n            if (v0.Y > v2.Y) (v0, v2) = (v2, v0);\r\n            if (v0.Y > v1.Y) (v0, v1) = (v1, v0);\r\n            if (v1.Y > v2.Y) (v1, v2) = (v2, v1);\r\n\r\n            // Градиенты для координат\r\n            var kv1 = (v2 - v0) / (v2.Y - v0.Y);\r\n            var kv2 = (v1 - v0) / (v1.Y - v0.Y);\r\n            var kv3 = (v2 - v1) / (v2.Y - v1.Y);\r\n\r\n            // Градиенты для UV\r\n            var kuv1 = (uv2 - uv0) / (v2.Y - v0.Y);\r\n            var kuv2 = (uv1 - uv0) / (v1.Y - v0.Y);\r\n            var kuv3 = (uv2 - uv1) / (v2.Y - v1.Y);\r\n\r\n            for (int y = (int)Math.Ceiling(v0.Y); y < Math.Min(_buffer.height, (int)v2.Y); y++)\r\n            {\r\n                var av = v0 + (y - v0.Y) * kv1;\r\n                var bv = (y < v1.Y) ? v0 + (y - v0.Y) * kv2 : v1 + (y - v1.Y) * kv3;\r\n\r\n                var auv = (y < v1.Y) ? uv0 + (y - v0.Y) * kuv2 : uv1 + (y - v1.Y) * kuv3;\r\n                var buv = uv0 + (y - v0.Y) * kuv1;\r\n\r\n                if (av.X > bv.X) (av, bv) = (bv, av);\r\n\r\n                var left = Math.Max(0, (int)Math.Ceiling(av.X));\r\n                var right = Math.Min(_buffer.width, (int)Math.Ceiling(bv.X));\r\n\r\n                for (int x = left; x < right; x++)\r\n                {\r\n                    var t = (x - av.X) / (bv.X - av.X);\r\n\r\n                    // Перспективная коррекция\r\n                    float one_over_z0 = 1.0f / av.W;\r\n                    float one_over_z1 = 1.0f / bv.W;\r\n                    float one_over_z = one_over_z0 * (1 - t) + one_over_z1 * t;\r\n\r\n                    float u_over_z = (auv.X * one_over_z0) * (1 - t) + (buv.X * one_over_z1) * t;\r\n                    float v_over_z = (auv.Y * one_over_z0) * (1 - t) + (buv.Y * one_over_z1) * t;\r\n\r\n                    float u = u_over_z / one_over_z;\r\n                    float v = v_over_z / one_over_z;\r\n                    float z = 1.0f / one_over_z;\r\n\r\n                    // Получение текстур\r\n                    var diffuseColor = GetTextureColor(model.DiffuseMap, u, v);\r\n                    var specularColor = GetTextureColor(model.SpecularMap, u, v);\r\n                    var normal = GetNormalFromMap(model.NormalMap, u, v);\r\n\r\n                    // Расчёт освещения\r\n                    var Ka = new Vector3(diffuseColor.R, diffuseColor.G, diffuseColor.B) / 255f;\r\n                    var Kd = Ka;\r\n                    var Ks = specularColor.R / 255f;\r\n\r\n                    var color = CalculatePhongColor(\r\n                        new Vector4(x, y, z, 1),\r\n                        normal,\r\n                        model.lightDir,\r\n                        model.target,\r\n                        Ka,\r\n                        Kd,\r\n                        new Vector3(Ks),\r\n                        model.Shininess,\r\n                        model.lightColor);\r\n\r\n                    // Применение цвета\r\n                    if (_buffer.PutZValue(x, y, z))\r\n                        _buffer[x, y] = Color.FromArgb(\r\n                            (int)(color.B * this.B / 255),\r\n                            (int)(color.G * this.G / 255),\r\n                            (int)(color.R * this.R / 255));\r\n                }\r\n            }\r\n        }\r\n\r\n        private Color GetTextureColor(Bitmap texture, float u, float v)\r\n        {\r\n            u = u - (float)Math.Floor(u);\r\n            v = v - (float)Math.Floor(v);\r\n            int x = (int)(u * (texture.Width - 1));\r\n            int y = (int)((1 - v) * (texture.Height - 1));\r\n            return texture.GetPixel(x, y);\r\n        }\r\n\r\n        private Vector3 GetNormalFromMap(Bitmap normalMap, float u, float v)\r\n        {\r\n            u = u - (float)Math.Floor(u);\r\n            v = v - (float)Math.Floor(v);\r\n            int x = (int)(u * (normalMap.Width - 1));\r\n            int y = (int)((1 - v) * (normalMap.Height - 1));\r\n            var color = normalMap.GetPixel(x, y);\r\n            return new Vector3(\r\n                color.R / 255f * 2 - 1,\r\n                color.G / 255f * 2 - 1,\r\n                color.B / 255f * 2 - 1);\r\n        }\r\n        #endregion*/\r\n\r\n\r\n        #region 4 laba tmp\r\n\r\n\r\n\r\n        private Color CalculatePhongColor2(Vector4 position4, Vector3 normal, Vector3 lightDir, Vector3 viewDir,\r\n         Vector3 Ka, Vector3 Kd, Vector3 Ks, float shininess, Vector3 lightColor)\r\n        {\r\n            var position = new Vector3(position4.X, position4.Y, position4.Z);\r\n            normal = Vector3.Normalize(normal);\r\n            lightDir = Vector3.Normalize(-lightDir);\r\n            viewDir = Vector3.Normalize(viewDir - position);\r\n\r\n            // Фоновое освещение\r\n            Vector3 ambient = Ka * lightColor ;\r\n            // Рассеянное освещение\r\n            float diff = Math.Max(Vector3.Dot(normal, lightDir), 0);\r\n            Vector3 diffuse = Kd * diff * lightColor;\r\n            // Зеркальное освещение\r\n            Vector3 reflectDir = Vector3.Reflect(-lightDir, normal);\r\n            float spec = (float)Math.Pow(Math.Max(Vector3.Dot(viewDir, reflectDir), 0), shininess);\r\n            Vector3 specular = Ks * spec * lightColor;\r\n            // Суммируем компоненты\r\n            Vector3 finalColor = ambient + diffuse + specular;\r\n\r\n            // Преобразуем в Color (ограничиваем значения 0-1)\r\n            finalColor = Vector3.Clamp(finalColor, Vector3.Zero, Vector3.One);\r\n            return Color.FromArgb(\r\n                (int)(finalColor.Z * lightColor.Z * 255),\r\n                (int)(finalColor.Y * lightColor.Y * 255),\r\n                (int)(finalColor.X * lightColor.X * 255));\r\n        }\r\n        public void PaintModelLaba4(Model model)\r\n        {\r\n            model.CalculateVertices(_buffer.width, _buffer.height);\r\n\r\n            var modelUVs = model.GetModelTextureCoordinates();\r\n\r\n            foreach (var face in model.GetModelFaces())\r\n            {\r\n                var v0 = model.GetViewPortVertices()[face.Indices[0].VertexIndex - 1];\r\n                var v1 = model.GetViewPortVertices()[face.Indices[1].VertexIndex - 1];\r\n                var v2 = model.GetViewPortVertices()[face.Indices[2].VertexIndex - 1];\r\n\r\n                // Backface culling\r\n                var edge1 = v1 - v0;\r\n                var edge2 = v2 - v0;\r\n                var normal = Vector3.Normalize(Vector3.Cross(\r\n                    new Vector3(edge1.X, edge1.Y, edge1.Z),\r\n                    new Vector3(edge2.X, edge2.Y, edge2.Z)));\r\n\r\n                if (Vector3.Dot(normal, model.target) > 0)\r\n                {\r\n                    var wv0 = model.GetWorldVertices()[face.Indices[0].VertexIndex - 1];\r\n                    var wv1 = model.GetWorldVertices()[face.Indices[1].VertexIndex - 1];\r\n                    var wv2 = model.GetWorldVertices()[face.Indices[2].VertexIndex - 1];\r\n\r\n                    var uv0 = modelUVs[face.Indices[0].TextureIndex - 1];\r\n                    var uv1 = modelUVs[face.Indices[1].TextureIndex - 1];\r\n                    var uv2 = modelUVs[face.Indices[2].TextureIndex - 1];\r\n\r\n                    DrawTexturedTriangle(\r\n                        new Vector4(v0.X, v0.Y, wv0.Z, v0.W),\r\n                        new Vector4(v1.X, v1.Y, wv1.Z, v1.W),\r\n                        new Vector4(v2.X, v2.Y, wv2.Z, v2.W),\r\n                        uv0, uv1, uv2,\r\n                        model);\r\n                }\r\n            }\r\n\r\n            _buffer.Flush();\r\n        }\r\n\r\n        private void DrawTexturedTriangle(Vector4 v0, Vector4 v1, Vector4 v2,\r\n    Vector3 uv0, Vector3 uv1, Vector3 uv2,\r\n    Model model)\r\n        {\r\n            // Сортировка вершин по Y\r\n            if (v0.Y > v2.Y) { (v0, v2) = (v2, v0); (uv0, uv2) = (uv2, uv0); }\r\n            if (v0.Y > v1.Y) { (v0, v1) = (v1, v0); (uv0, uv1) = (uv1, uv0); }\r\n            if (v1.Y > v2.Y) { (v1, v2) = (v2, v1); (uv1, uv2) = (uv2, uv1); }\r\n\r\n            // Вычисляем градиенты для координат X, Z и 1/W (для перспективно-корректной интерполяции)\r\n            float deltaY = v2.Y - v0.Y;\r\n            var kv1 = deltaY != 0 ? (v2 - v0) / deltaY : Vector4.Zero;\r\n            var kuv1 = deltaY != 0 ? (uv2 / v2.W - uv0 / v0.W) / deltaY : Vector3.Zero;\r\n            var kInvW1 = deltaY != 0 ? (1 / v2.W - 1 / v0.W) / deltaY : 0f;\r\n\r\n            deltaY = v1.Y - v0.Y;\r\n            var kv2 = deltaY != 0 ? (v1 - v0) / deltaY : Vector4.Zero;\r\n            var kuv2 = deltaY != 0 ? (uv1 / v1.W - uv0 / v0.W) / deltaY : Vector3.Zero;\r\n            var kInvW2 = deltaY != 0 ? (1 / v1.W - 1 / v0.W) / deltaY : 0f;\r\n\r\n            deltaY = v2.Y - v1.Y;\r\n            var kv3 = deltaY != 0 ? (v2 - v1) / deltaY : Vector4.Zero;\r\n            var kuv3 = deltaY != 0 ? (uv2 / v2.W - uv1 / v1.W) / deltaY : Vector3.Zero;\r\n            var kInvW3 = deltaY != 0 ? (1 / v2.W - 1 / v1.W) / deltaY : 0f;\r\n\r\n            // Границы растеризации\r\n            var top = Math.Max(0, (int)Math.Ceiling(v0.Y));\r\n            var bottom = Math.Min(_buffer.height, (int)Math.Ceiling(v2.Y));\r\n\r\n            for (int y = top; y < bottom; y++)\r\n            {\r\n                Vector4 av, bv;\r\n                Vector3 auvPersp, buvPersp;\r\n                float aInvW, bInvW;\r\n\r\n                if (y < v1.Y)\r\n                {\r\n                    var t = y - v0.Y;\r\n                    av = v0 + t * kv1;\r\n                    bv = v0 + t * kv2;\r\n                    auvPersp = uv0 / v0.W + t * kuv1;\r\n                    buvPersp = uv0 / v0.W + t * kuv2;\r\n                    aInvW = 1 / v0.W + t * kInvW1;\r\n                    bInvW = 1 / v0.W + t * kInvW2;\r\n                }\r\n                else\r\n                {\r\n                    var t = y - v1.Y;\r\n                    av = v1 + t * kv3;\r\n                    bv = v0 + (y - v0.Y) * kv1;\r\n                    auvPersp = uv1 / v1.W + t * kuv3;\r\n                    buvPersp = uv0 / v0.W + (y - v0.Y) * kuv1;\r\n                    aInvW = 1 / v1.W + t * kInvW3;\r\n                    bInvW = 1 / v0.W + (y - v0.Y) * kInvW1;\r\n                }\r\n\r\n                if (av.X > bv.X)\r\n                {\r\n                    (av, bv) = (bv, av);\r\n                    (auvPersp, buvPersp) = (buvPersp, auvPersp);\r\n                    (aInvW, bInvW) = (bInvW, aInvW);\r\n                }\r\n\r\n                var left = Math.Max(0, (int)Math.Ceiling(av.X));\r\n                var right = Math.Min(_buffer.width, (int)Math.Ceiling(bv.X));\r\n                var step = bv.X - av.X;\r\n                var k = step != 0 ? 1.0f / step : 0;\r\n\r\n                for (int x = left; x < right; x++)\r\n                {\r\n                    var t = (x - av.X) * k;\r\n                    var invW = aInvW * (1 - t) + bInvW * t;\r\n                    var z = 1 / invW; // Корректное значение глубины\r\n                  \r\n                    // Перспективно-корректные UV\r\n                    var uvPersp = auvPersp * (1 - t) + buvPersp * t;\r\n                    var uv = uvPersp * z;\r\n\r\n                    // Получаем данные из текстур\r\n                    var texColor = GetTextureColor(model.DiffuseMap, uv.X, uv.Y);\r\n                    var normal = GetNormalFromMap(model.NormalMap, uv.X, uv.Y);\r\n                    var specular = GetSpecularIntensity(model.SpecularMap, uv.X, uv.Y);\r\n\r\n                    // Преобразование нормали\r\n                    normal = Vector3.Normalize(normal * 2 - Vector3.One);\r\n\r\n                    // Расчет освещения\r\n                    var Ka = new Vector3(texColor.R / 255f, texColor.G / 255f, texColor.B / 255f);\r\n                    var color = CalculatePhongColor2(\r\n                        new Vector4(x, y, z, 1), // Используем корректное значение z\r\n                        normal, \r\n                        model.lightDir,\r\n                        model.target,\r\n                        Ka,\r\n                        Ka,\r\n                        new Vector3(specular),\r\n                        model.Shininess,\r\n                        model.lightColor);\r\n                   \r\n                    // Запись в буфер (используем z для проверки глубины)\r\n                    if (_buffer.PutZValue(x, y, 1/z))\r\n                        _buffer[x, y] = color;\r\n                }\r\n            }\r\n        }\r\n\r\n        private float GetSpecularIntensity(Bitmap specularMap, float u, float v)\r\n        {\r\n            var color = GetTextureColor(specularMap, u, v);\r\n            return (color.R + color.G + color.B) / (3 * 255f);\r\n        }\r\n        private Color GetTextureColor(Bitmap texture, float u, float v)\r\n        {\r\n            // Обеспечиваем повторение текстуры (tiling)\r\n            u = u - (float)Math.Floor(u);\r\n            v = v - (float)Math.Floor(v);\r\n\r\n            // Преобразуем UV в координаты текстуры\r\n            int x = (int)(u * (texture.Width - 1));\r\n            int y = (int)((1 - v) * (texture.Height - 1)); // Инвертируем V\r\n\r\n            // Получаем цвет текстуры\r\n            return texture.GetPixel(x, y);\r\n        }\r\n\r\n        private Vector3 GetNormalFromMap(Bitmap normalMap, float u, float v)\r\n        {\r\n            // Обеспечиваем повторение текстуры (tiling)\r\n            u = u - (float)Math.Floor(u);\r\n            v = v - (float)Math.Floor(v);\r\n\r\n            // Преобразуем UV в координаты текстуры\r\n            int x = (int)(u * (normalMap.Width - 1));\r\n            int y = (int)((1 - v) * (normalMap.Height - 1)); // Инвертируем V\r\n\r\n            // Получаем цвет из карты нормалей\r\n            var color = normalMap.GetPixel(x, y);\r\n\r\n            // Преобразуем цвет в вектор нормали (значения в [0,1])\r\n            return new Vector3(\r\n                color.R / 255f,\r\n                color.G / 255f,\r\n                color.B / 255f);\r\n        }\r\n        // Остальные методы без изменений\r\n        #endregion\r\n\r\n         /*#region Четвертая лаба\r\n         public void PaintModelLaba4(Model model)\r\n         {\r\n             model.CalculateVertices(_buffer.width, _buffer.height);\r\n\r\n             var modelNormals = model.GetNormals();\r\n             var modelUVs = model.GetModelTextureCoordinates(); // Получаем UV-координаты\r\n\r\n             foreach (var face in model.GetModelFaces())\r\n             {\r\n                 var v0 = model.GetViewPortVertices()[face.Indices[0].VertexIndex - 1];\r\n                 var v1 = model.GetViewPortVertices()[face.Indices[1].VertexIndex - 1];\r\n                 var v2 = model.GetViewPortVertices()[face.Indices[2].VertexIndex - 1];\r\n\r\n                 // Backface culling\r\n                 var edge1 = v1 - v0;\r\n                 var edge2 = v2 - v0;\r\n                 var normal = Vector3.Normalize(Vector3.Cross(\r\n                     new Vector3(edge1.X, edge1.Y, edge1.Z),\r\n                     new Vector3(edge2.X, edge2.Y, edge2.Z)));\r\n\r\n                 if (Vector3.Dot(normal, model.target) > 0)\r\n                 {\r\n                     // Мировые координаты вершин\r\n                     var wv0 = model.GetWorldVertices()[face.Indices[0].VertexIndex - 1];\r\n                     var wv1 = model.GetWorldVertices()[face.Indices[1].VertexIndex - 1];\r\n                     var wv2 = model.GetWorldVertices()[face.Indices[2].VertexIndex - 1];\r\n\r\n                     // Нормали вершин\r\n                     var n0 = modelNormals[face.Indices[0].VertexIndex - 1];\r\n                     var n1 = modelNormals[face.Indices[1].VertexIndex - 1];\r\n                     var n2 = modelNormals[face.Indices[2].VertexIndex - 1];\r\n\r\n                     // UV-координаты вершин\r\n                     var uv0 = modelUVs[face.Indices[0].TextureIndex - 1];\r\n                     var uv1 = modelUVs[face.Indices[1].TextureIndex - 1];\r\n                     var uv2 = modelUVs[face.Indices[2].TextureIndex - 1];\r\n\r\n                     // Рисуем треугольник с учетом текстуры\r\n                     DrawTexturedTriangle(\r\n                         new Vector4(v0.X, v0.Y, wv0.Z, v0.W),\r\n                         new Vector4(v1.X, v1.Y, wv1.Z, v1.W),\r\n                         new Vector4(v2.X, v2.Y, wv2.Z, v2.W),\r\n                         n0, n1, n2,\r\n                         uv0, uv1, uv2,\r\n                         model);\r\n                 }\r\n             }\r\n\r\n             _buffer.Flush();\r\n         }\r\n\r\n         private void DrawTexturedTriangle(Vector4 v0, Vector4 v1, Vector4 v2,\r\n             Vector3 n0, Vector3 n1, Vector3 n2,\r\n             Vector3 uv0, Vector3 uv1, Vector3 uv2,\r\n             Model model)\r\n         {\r\n             // Сортировка вершин по Y (v0.Y <= v1.Y <= v2.Y)\r\n             if (v0.Y > v2.Y)\r\n             {\r\n                 (v0, v2) = (v2, v0);\r\n                 (n0, n2) = (n2, n0);\r\n                 (uv0, uv2) = (uv2, uv0);\r\n             }\r\n\r\n             if (v0.Y > v1.Y)\r\n             {\r\n                 (v0, v1) = (v1, v0);\r\n                 (n0, n1) = (n1, n0);\r\n                 (uv0, uv1) = (uv1, uv0);\r\n             }\r\n\r\n             if (v1.Y > v2.Y)\r\n             {\r\n                 (v1, v2) = (v2, v1);\r\n                 (n1, n2) = (n2, n1);\r\n                 (uv1, uv2) = (uv2, uv1);\r\n             }\r\n\r\n             // Вычисление градиентов для координат X и Z\r\n             var kv1 = (v2 - v0) / (v2.Y - v0.Y);\r\n             var kv2 = (v1 - v0) / (v1.Y - v0.Y);\r\n             var kv3 = (v2 - v1) / (v2.Y - v1.Y);\r\n\r\n             // Градиенты для нормалей\r\n             var kn1 = (n2 - n0) / (v2.Y - v0.Y);\r\n             var kn2 = (n1 - n0) / (v1.Y - v0.Y);\r\n             var kn3 = (n2 - n1) / (v2.Y - v1.Y);\r\n\r\n             // Градиенты для UV\r\n             var kuv1 = (uv2 - uv0) / (v2.Y - v0.Y);\r\n             var kuv2 = (uv1 - uv0) / (v1.Y - v0.Y);\r\n             var kuv3 = (uv2 - uv1) / (v2.Y - v1.Y);\r\n\r\n             // Границы по Y\r\n             var top = Math.Max(0, (int)Math.Ceiling(v0.Y));\r\n             var bottom = Math.Min(_buffer.height, (int)Math.Ceiling(v2.Y));\r\n\r\n             // Цикл по строкам\r\n             for (int y = top; y < bottom; y++)\r\n             {\r\n                 // Определяем крайние точки\r\n                 var av = v0 + (y - v0.Y) * kv1;\r\n                 var bv = (y < v1.Y) ? v0 + (y - v0.Y) * kv2 : v1 + (y - v1.Y) * kv3;\r\n\r\n                 // Нормали для крайних точек\r\n                 var an = (y < v1.Y) ? n0 + (y - v0.Y) * kn2 : n1 + (y - v1.Y) * kn3;\r\n                 var bn = n0 + (y - v0.Y) * kn1;\r\n\r\n                 // UV для крайних точек\r\n                 var auv = (y < v1.Y) ? uv0 + (y - v0.Y) * kuv2 : uv1 + (y - v1.Y) * kuv3;\r\n                 var buv = uv0 + (y - v0.Y) * kuv1;\r\n\r\n                 // Упорядочиваем крайние точки\r\n                 if (av.X > bv.X)\r\n                 {\r\n                     (av, bv) = (bv, av);\r\n                     (an, bn) = (bn, an);\r\n                     (auv, buv) = (buv, auv);\r\n                 }\r\n\r\n                 // Рисуем горизонтальную линию от av.X до bv.X\r\n                 var left = Math.Max(0, (int)Math.Ceiling(av.X));\r\n                 var right = Math.Min(_buffer.width, (int)Math.Ceiling(bv.X));\r\n\r\n                 // Интерполяция между крайними точками\r\n                 var step = bv.X - av.X;\r\n                 var k = (step != 0) ? 1.0f / step : 0;\r\n\r\n                 for (int x = left; x < right; x++)\r\n                 {\r\n                     var t = (x - av.X) * k;\r\n\r\n                     // Интерполируем Z\r\n                     var z = av.Z + (bv.Z - av.Z) * t;\r\n\r\n                    // Интерполируем нормаль\r\n                    //var normal = Vector3.Normalize(an + (bn - an) * t);\r\n\r\n                    // Интерполируем UV\r\n                    //var uv = auv + (buv - auv) * t;\r\n\r\n\r\n                    var auv_div_z = auv / av.Z;  // uv0 / z0\r\n                    var buv_div_z = buv / bv.Z;  // uv1 / z1\r\n                    var a_inv_z = 1.0f / av.Z;   // 1 / z0\r\n                    var b_inv_z = 1.0f / bv.Z;   // 1 / z1\r\n\r\n                    // 2. Линейно интерполируем (uv/z) и (1/z)\r\n                    var uv_div_z_interp = auv_div_z + (buv_div_z - auv_div_z) * t;  // (1-t)*(uv0/z0) + t*(uv1/z1)\r\n                    var inv_z_interp = a_inv_z + (b_inv_z - a_inv_z) * t;           // (1-t)*(1/z0) + t*(1/z1)\r\n\r\n                    // 3. Восстанавливаем uv: uv = (uv/z) / (1/z)\r\n                    var uv = uv_div_z_interp / inv_z_interp;\r\n\r\n                    // Получаем цвет из текстуры\r\n                    var texColor = GetTextureColor(model.DiffuseMap, uv.X, uv.Y);\r\n\r\n                     // Используем цвет текстуры как kd и ka\r\n                     var Ka = new Vector3(texColor.R / 255f, texColor.G / 255f, texColor.B / 255f);\r\n                     var Kd = Ka; // Обычно диффузная карта используется и для kd и для ka\r\n\r\n                     var normalFromMap = GetNormalFromMap(model.NormalMap, uv.X, uv.Y);\r\n\r\n                     // Преобразуем нормаль из [0,1] в [-1,1] и нормализуем\r\n                     var normal = Vector3.Normalize(normalFromMap * 2 - Vector3.One);\r\n\r\n                     // Вычисляем цвет по Фонгу с учетом текстуры\r\n                     var color = CalculatePhongColor(\r\n                         new Vector4(x, y, z, 1),\r\n                         normal,\r\n                         model.lightDir,\r\n                         model.target,\r\n                         Ka,\r\n                         Kd,\r\n                         model.Ks,\r\n                         model.Shininess,\r\n                         model.lightColor);\r\n\r\n                     // Применяем основной цвет объекта\r\n                     color = Color.FromArgb(\r\n                         (int)(color.B * this.B / 255),\r\n                         (int)(color.G * this.G / 255),\r\n                         (int)(color.R * this.R / 255));\r\n\r\n                     if (_buffer.PutZValue(x, y, z))\r\n                         _buffer[x, y] = color;\r\n                 }\r\n             }\r\n         }\r\n\r\n         private Color GetTextureColor(Bitmap texture, float u, float v)\r\n         {\r\n             // Обеспечиваем повторение текстуры (tiling)\r\n             u = u - (float)Math.Floor(u);\r\n             v = v - (float)Math.Floor(v);\r\n\r\n             // Преобразуем UV в координаты текстуры\r\n             int x = (int)(u * (texture.Width - 1));\r\n             int y = (int)((1 - v) * (texture.Height - 1)); // Инвертируем V\r\n\r\n             // Получаем цвет текстуры\r\n             return texture.GetPixel(x, y);\r\n         }\r\n\r\n         private Vector3 GetNormalFromMap(Bitmap normalMap, float u, float v)\r\n         {\r\n             // Обеспечиваем повторение текстуры (tiling)\r\n             u = u - (float)Math.Floor(u);\r\n             v = v - (float)Math.Floor(v);\r\n\r\n             // Преобразуем UV в координаты текстуры\r\n             int x = (int)(u * (normalMap.Width - 1));\r\n             int y = (int)((1 - v) * (normalMap.Height - 1)); // Инвертируем V\r\n\r\n             // Получаем цвет из карты нормалей\r\n             var color = normalMap.GetPixel(x, y);\r\n\r\n             // Преобразуем цвет в вектор нормали (значения в [0,1])\r\n             return new Vector3(\r\n                 color.R / 255f,\r\n                 color.G / 255f,\r\n                 color.B / 255f);\r\n         }\r\n         #endregion*/\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Drawing/Painter.cs b/Drawing/Painter.cs
--- a/Drawing/Painter.cs	(revision dc8ea09344de44f0ccb8d230f234d3119f4cf238)
+++ b/Drawing/Painter.cs	(date 1745508402104)
@@ -25,6 +25,7 @@
 
 
         #region Первая лаба
+
         private void DrawLine(int xStart, int yStart, int xEnd, int yEnd)
         {
             int dx = xEnd - xStart;
@@ -116,10 +117,12 @@
             //пишем из буфера
             _buffer.Flush();
         }
+
         #endregion
 
 
         #region Вторая лаба
+
         private void DrawTriangle(Vector4 v0, Vector4 v1, Vector4 v2, Color color)
         {
             // Сортировка вершин по Y (v0.Y <= v1.Y <= v2.Y)
@@ -230,20 +233,39 @@
             //пишем из буфера
             _buffer.Flush();
         }
+
         #endregion
 
 
         #region Третья лаба
+
         private void DrawTriangleWithPhongInterpolation(
-    Vector4 v0, Vector4 v1, Vector4 v2,
-    Vector3 n0, Vector3 n1, Vector3 n2,
-    Vector3 worldPos0, Vector3 worldPos1, Vector3 worldPos2,
-    Vector3 Ka, Vector3 Kd, Vector3 Ks, float shininess, Vector3 lightDir, Vector3 viewDir, Vector3 lightColor)
+            Vector4 v0, Vector4 v1, Vector4 v2,
+            Vector3 n0, Vector3 n1, Vector3 n2,
+            Vector3 worldPos0, Vector3 worldPos1, Vector3 worldPos2,
+            Vector3 Ka, Vector3 Kd, Vector3 Ks, float shininess, Vector3 lightDir, Vector3 viewDir, Vector3 lightColor)
         {
             // Сортировка вершин по Y (v0.Y <= v1.Y <= v2.Y)
-            if (v0.Y > v2.Y) { (v0, v2) = (v2, v0); (n0, n2) = (n2, n0); (worldPos0, worldPos2) = (worldPos2, worldPos0); }
-            if (v0.Y > v1.Y) { (v0, v1) = (v1, v0); (n0, n1) = (n1, n0); (worldPos0, worldPos1) = (worldPos1, worldPos0); }
-            if (v1.Y > v2.Y) { (v1, v2) = (v2, v1); (n1, n2) = (n2, n1); (worldPos1, worldPos2) = (worldPos2, worldPos1); }
+            if (v0.Y > v2.Y)
+            {
+                (v0, v2) = (v2, v0);
+                (n0, n2) = (n2, n0);
+                (worldPos0, worldPos2) = (worldPos2, worldPos0);
+            }
+
+            if (v0.Y > v1.Y)
+            {
+                (v0, v1) = (v1, v0);
+                (n0, n1) = (n1, n0);
+                (worldPos0, worldPos1) = (worldPos1, worldPos0);
+            }
+
+            if (v1.Y > v2.Y)
+            {
+                (v1, v2) = (v2, v1);
+                (n1, n2) = (n2, n1);
+                (worldPos1, worldPos2) = (worldPos2, worldPos1);
+            }
 
             // Вычисление градиентов для координат X, Z и нормалей
             var kv1 = (v2 - v0) / (v2.Y - v0.Y);
@@ -370,6 +392,7 @@
 
             _buffer.Flush();
         }
+
         private void DrawTriangleWithInterpolation(Vector4 v0, Vector4 v1, Vector4 v2, Color c0, Color c1, Color c2)
         {
             // Сортировка вершин по Y (v0.Y <= v1.Y <= v2.Y)
@@ -480,7 +503,7 @@
             Vector3 ambient = Ka * lightColor * 1f;
             // Рассеянное освещение
             float diff = Math.Max(Vector3.Dot(normal, lightDir), 0);
-            Vector3 diffuse = Kd * diff * lightColor;   
+            Vector3 diffuse = Kd * diff * lightColor;
             // Зеркальное освещение
             Vector3 reflectDir = Vector3.Reflect(-lightDir, normal);
             float spec = (float)Math.Pow(Math.Max(Vector3.Dot(viewDir, reflectDir), 0), shininess);
@@ -495,6 +518,7 @@
                 (int)(finalColor.Y * this.G),
                 (int)(finalColor.Z * this.R));
         }
+
         #endregion
 
         /*#region asdasdsadadas
@@ -838,10 +862,8 @@
 
         #region 4 laba tmp
 
-
-
         private Color CalculatePhongColor2(Vector4 position4, Vector3 normal, Vector3 lightDir, Vector3 viewDir,
-         Vector3 Ka, Vector3 Kd, Vector3 Ks, float shininess, Vector3 lightColor)
+            Vector3 Ka, Vector3 Kd, Vector3 Ks, float shininess, Vector3 lightColor)
         {
             var position = new Vector3(position4.X, position4.Y, position4.Z);
             normal = Vector3.Normalize(normal);
@@ -849,7 +871,7 @@
             viewDir = Vector3.Normalize(viewDir - position);
 
             // Фоновое освещение
-            Vector3 ambient = Ka * lightColor ;
+            Vector3 ambient = Ka * lightColor;
             // Рассеянное освещение
             float diff = Math.Max(Vector3.Dot(normal, lightDir), 0);
             Vector3 diffuse = Kd * diff * lightColor;
@@ -867,6 +889,7 @@
                 (int)(finalColor.Y * lightColor.Y * 255),
                 (int)(finalColor.X * lightColor.X * 255));
         }
+
         public void PaintModelLaba4(Model model)
         {
             model.CalculateVertices(_buffer.width, _buffer.height);
@@ -909,13 +932,27 @@
         }
 
         private void DrawTexturedTriangle(Vector4 v0, Vector4 v1, Vector4 v2,
-    Vector3 uv0, Vector3 uv1, Vector3 uv2,
-    Model model)
+            Vector3 uv0, Vector3 uv1, Vector3 uv2,
+            Model model)
         {
             // Сортировка вершин по Y
-            if (v0.Y > v2.Y) { (v0, v2) = (v2, v0); (uv0, uv2) = (uv2, uv0); }
-            if (v0.Y > v1.Y) { (v0, v1) = (v1, v0); (uv0, uv1) = (uv1, uv0); }
-            if (v1.Y > v2.Y) { (v1, v2) = (v2, v1); (uv1, uv2) = (uv2, uv1); }
+            if (v0.Y > v2.Y)
+            {
+                (v0, v2) = (v2, v0);
+                (uv0, uv2) = (uv2, uv0);
+            }
+
+            if (v0.Y > v1.Y)
+            {
+                (v0, v1) = (v1, v0);
+                (uv0, uv1) = (uv1, uv0);
+            }
+
+            if (v1.Y > v2.Y)
+            {
+                (v1, v2) = (v2, v1);
+                (uv1, uv2) = (uv2, uv1);
+            }
 
             // Вычисляем градиенты для координат X, Z и 1/W (для перспективно-корректной интерполяции)
             float deltaY = v2.Y - v0.Y;
@@ -981,7 +1018,7 @@
                     var t = (x - av.X) * k;
                     var invW = aInvW * (1 - t) + bInvW * t;
                     var z = 1 / invW; // Корректное значение глубины
-                  
+
                     // Перспективно-корректные UV
                     var uvPersp = auvPersp * (1 - t) + buvPersp * t;
                     var uv = uvPersp * z;
@@ -998,7 +1035,7 @@
                     var Ka = new Vector3(texColor.R / 255f, texColor.G / 255f, texColor.B / 255f);
                     var color = CalculatePhongColor2(
                         new Vector4(x, y, z, 1), // Используем корректное значение z
-                        normal, 
+                        normal,
                         model.lightDir,
                         model.target,
                         Ka,
@@ -1006,9 +1043,9 @@
                         new Vector3(specular),
                         model.Shininess,
                         model.lightColor);
-                   
+
                     // Запись в буфер (используем z для проверки глубины)
-                    if (_buffer.PutZValue(x, y, 1/z))
+                    if (_buffer.PutZValue(x, y, 1 / z))
                         _buffer[x, y] = color;
                 }
             }
@@ -1019,6 +1056,7 @@
             var color = GetTextureColor(specularMap, u, v);
             return (color.R + color.G + color.B) / (3 * 255f);
         }
+
         private Color GetTextureColor(Bitmap texture, float u, float v)
         {
             // Обеспечиваем повторение текстуры (tiling)
@@ -1052,233 +1090,235 @@
                 color.G / 255f,
                 color.B / 255f);
         }
+
         // Остальные методы без изменений
+
         #endregion
 
-         /*#region Четвертая лаба
-         public void PaintModelLaba4(Model model)
-         {
-             model.CalculateVertices(_buffer.width, _buffer.height);
+        /*#region Четвертая лаба
+        public void PaintModelLaba4(Model model)
+        {
+            model.CalculateVertices(_buffer.width, _buffer.height);
 
-             var modelNormals = model.GetNormals();
-             var modelUVs = model.GetModelTextureCoordinates(); // Получаем UV-координаты
+            var modelNormals = model.GetNormals();
+            var modelUVs = model.GetModelTextureCoordinates(); // Получаем UV-координаты
 
-             foreach (var face in model.GetModelFaces())
-             {
-                 var v0 = model.GetViewPortVertices()[face.Indices[0].VertexIndex - 1];
-                 var v1 = model.GetViewPortVertices()[face.Indices[1].VertexIndex - 1];
-                 var v2 = model.GetViewPortVertices()[face.Indices[2].VertexIndex - 1];
+            foreach (var face in model.GetModelFaces())
+            {
+                var v0 = model.GetViewPortVertices()[face.Indices[0].VertexIndex - 1];
+                var v1 = model.GetViewPortVertices()[face.Indices[1].VertexIndex - 1];
+                var v2 = model.GetViewPortVertices()[face.Indices[2].VertexIndex - 1];
 
-                 // Backface culling
-                 var edge1 = v1 - v0;
-                 var edge2 = v2 - v0;
-                 var normal = Vector3.Normalize(Vector3.Cross(
-                     new Vector3(edge1.X, edge1.Y, edge1.Z),
-                     new Vector3(edge2.X, edge2.Y, edge2.Z)));
+                // Backface culling
+                var edge1 = v1 - v0;
+                var edge2 = v2 - v0;
+                var normal = Vector3.Normalize(Vector3.Cross(
+                    new Vector3(edge1.X, edge1.Y, edge1.Z),
+                    new Vector3(edge2.X, edge2.Y, edge2.Z)));
 
-                 if (Vector3.Dot(normal, model.target) > 0)
-                 {
-                     // Мировые координаты вершин
-                     var wv0 = model.GetWorldVertices()[face.Indices[0].VertexIndex - 1];
-                     var wv1 = model.GetWorldVertices()[face.Indices[1].VertexIndex - 1];
-                     var wv2 = model.GetWorldVertices()[face.Indices[2].VertexIndex - 1];
+                if (Vector3.Dot(normal, model.target) > 0)
+                {
+                    // Мировые координаты вершин
+                    var wv0 = model.GetWorldVertices()[face.Indices[0].VertexIndex - 1];
+                    var wv1 = model.GetWorldVertices()[face.Indices[1].VertexIndex - 1];
+                    var wv2 = model.GetWorldVertices()[face.Indices[2].VertexIndex - 1];
 
-                     // Нормали вершин
-                     var n0 = modelNormals[face.Indices[0].VertexIndex - 1];
-                     var n1 = modelNormals[face.Indices[1].VertexIndex - 1];
-                     var n2 = modelNormals[face.Indices[2].VertexIndex - 1];
+                    // Нормали вершин
+                    var n0 = modelNormals[face.Indices[0].VertexIndex - 1];
+                    var n1 = modelNormals[face.Indices[1].VertexIndex - 1];
+                    var n2 = modelNormals[face.Indices[2].VertexIndex - 1];
 
-                     // UV-координаты вершин
-                     var uv0 = modelUVs[face.Indices[0].TextureIndex - 1];
-                     var uv1 = modelUVs[face.Indices[1].TextureIndex - 1];
-                     var uv2 = modelUVs[face.Indices[2].TextureIndex - 1];
+                    // UV-координаты вершин
+                    var uv0 = modelUVs[face.Indices[0].TextureIndex - 1];
+                    var uv1 = modelUVs[face.Indices[1].TextureIndex - 1];
+                    var uv2 = modelUVs[face.Indices[2].TextureIndex - 1];
 
-                     // Рисуем треугольник с учетом текстуры
-                     DrawTexturedTriangle(
-                         new Vector4(v0.X, v0.Y, wv0.Z, v0.W),
-                         new Vector4(v1.X, v1.Y, wv1.Z, v1.W),
-                         new Vector4(v2.X, v2.Y, wv2.Z, v2.W),
-                         n0, n1, n2,
-                         uv0, uv1, uv2,
-                         model);
-                 }
-             }
+                    // Рисуем треугольник с учетом текстуры
+                    DrawTexturedTriangle(
+                        new Vector4(v0.X, v0.Y, wv0.Z, v0.W),
+                        new Vector4(v1.X, v1.Y, wv1.Z, v1.W),
+                        new Vector4(v2.X, v2.Y, wv2.Z, v2.W),
+                        n0, n1, n2,
+                        uv0, uv1, uv2,
+                        model);
+                }
+            }
 
-             _buffer.Flush();
-         }
+            _buffer.Flush();
+        }
 
-         private void DrawTexturedTriangle(Vector4 v0, Vector4 v1, Vector4 v2,
-             Vector3 n0, Vector3 n1, Vector3 n2,
-             Vector3 uv0, Vector3 uv1, Vector3 uv2,
-             Model model)
-         {
-             // Сортировка вершин по Y (v0.Y <= v1.Y <= v2.Y)
-             if (v0.Y > v2.Y)
-             {
-                 (v0, v2) = (v2, v0);
-                 (n0, n2) = (n2, n0);
-                 (uv0, uv2) = (uv2, uv0);
-             }
+        private void DrawTexturedTriangle(Vector4 v0, Vector4 v1, Vector4 v2,
+            Vector3 n0, Vector3 n1, Vector3 n2,
+            Vector3 uv0, Vector3 uv1, Vector3 uv2,
+            Model model)
+        {
+            // Сортировка вершин по Y (v0.Y <= v1.Y <= v2.Y)
+            if (v0.Y > v2.Y)
+            {
+                (v0, v2) = (v2, v0);
+                (n0, n2) = (n2, n0);
+                (uv0, uv2) = (uv2, uv0);
+            }
 
-             if (v0.Y > v1.Y)
-             {
-                 (v0, v1) = (v1, v0);
-                 (n0, n1) = (n1, n0);
-                 (uv0, uv1) = (uv1, uv0);
-             }
+            if (v0.Y > v1.Y)
+            {
+                (v0, v1) = (v1, v0);
+                (n0, n1) = (n1, n0);
+                (uv0, uv1) = (uv1, uv0);
+            }
 
-             if (v1.Y > v2.Y)
-             {
-                 (v1, v2) = (v2, v1);
-                 (n1, n2) = (n2, n1);
-                 (uv1, uv2) = (uv2, uv1);
-             }
+            if (v1.Y > v2.Y)
+            {
+                (v1, v2) = (v2, v1);
+                (n1, n2) = (n2, n1);
+                (uv1, uv2) = (uv2, uv1);
+            }
 
-             // Вычисление градиентов для координат X и Z
-             var kv1 = (v2 - v0) / (v2.Y - v0.Y);
-             var kv2 = (v1 - v0) / (v1.Y - v0.Y);
-             var kv3 = (v2 - v1) / (v2.Y - v1.Y);
+            // Вычисление градиентов для координат X и Z
+            var kv1 = (v2 - v0) / (v2.Y - v0.Y);
+            var kv2 = (v1 - v0) / (v1.Y - v0.Y);
+            var kv3 = (v2 - v1) / (v2.Y - v1.Y);
 
-             // Градиенты для нормалей
-             var kn1 = (n2 - n0) / (v2.Y - v0.Y);
-             var kn2 = (n1 - n0) / (v1.Y - v0.Y);
-             var kn3 = (n2 - n1) / (v2.Y - v1.Y);
+            // Градиенты для нормалей
+            var kn1 = (n2 - n0) / (v2.Y - v0.Y);
+            var kn2 = (n1 - n0) / (v1.Y - v0.Y);
+            var kn3 = (n2 - n1) / (v2.Y - v1.Y);
 
-             // Градиенты для UV
-             var kuv1 = (uv2 - uv0) / (v2.Y - v0.Y);
-             var kuv2 = (uv1 - uv0) / (v1.Y - v0.Y);
-             var kuv3 = (uv2 - uv1) / (v2.Y - v1.Y);
+            // Градиенты для UV
+            var kuv1 = (uv2 - uv0) / (v2.Y - v0.Y);
+            var kuv2 = (uv1 - uv0) / (v1.Y - v0.Y);
+            var kuv3 = (uv2 - uv1) / (v2.Y - v1.Y);
 
-             // Границы по Y
-             var top = Math.Max(0, (int)Math.Ceiling(v0.Y));
-             var bottom = Math.Min(_buffer.height, (int)Math.Ceiling(v2.Y));
+            // Границы по Y
+            var top = Math.Max(0, (int)Math.Ceiling(v0.Y));
+            var bottom = Math.Min(_buffer.height, (int)Math.Ceiling(v2.Y));
 
-             // Цикл по строкам
-             for (int y = top; y < bottom; y++)
-             {
-                 // Определяем крайние точки
-                 var av = v0 + (y - v0.Y) * kv1;
-                 var bv = (y < v1.Y) ? v0 + (y - v0.Y) * kv2 : v1 + (y - v1.Y) * kv3;
+            // Цикл по строкам
+            for (int y = top; y < bottom; y++)
+            {
+                // Определяем крайние точки
+                var av = v0 + (y - v0.Y) * kv1;
+                var bv = (y < v1.Y) ? v0 + (y - v0.Y) * kv2 : v1 + (y - v1.Y) * kv3;
 
-                 // Нормали для крайних точек
-                 var an = (y < v1.Y) ? n0 + (y - v0.Y) * kn2 : n1 + (y - v1.Y) * kn3;
-                 var bn = n0 + (y - v0.Y) * kn1;
+                // Нормали для крайних точек
+                var an = (y < v1.Y) ? n0 + (y - v0.Y) * kn2 : n1 + (y - v1.Y) * kn3;
+                var bn = n0 + (y - v0.Y) * kn1;
 
-                 // UV для крайних точек
-                 var auv = (y < v1.Y) ? uv0 + (y - v0.Y) * kuv2 : uv1 + (y - v1.Y) * kuv3;
-                 var buv = uv0 + (y - v0.Y) * kuv1;
+                // UV для крайних точек
+                var auv = (y < v1.Y) ? uv0 + (y - v0.Y) * kuv2 : uv1 + (y - v1.Y) * kuv3;
+                var buv = uv0 + (y - v0.Y) * kuv1;
 
-                 // Упорядочиваем крайние точки
-                 if (av.X > bv.X)
-                 {
-                     (av, bv) = (bv, av);
-                     (an, bn) = (bn, an);
-                     (auv, buv) = (buv, auv);
-                 }
+                // Упорядочиваем крайние точки
+                if (av.X > bv.X)
+                {
+                    (av, bv) = (bv, av);
+                    (an, bn) = (bn, an);
+                    (auv, buv) = (buv, auv);
+                }
 
-                 // Рисуем горизонтальную линию от av.X до bv.X
-                 var left = Math.Max(0, (int)Math.Ceiling(av.X));
-                 var right = Math.Min(_buffer.width, (int)Math.Ceiling(bv.X));
+                // Рисуем горизонтальную линию от av.X до bv.X
+                var left = Math.Max(0, (int)Math.Ceiling(av.X));
+                var right = Math.Min(_buffer.width, (int)Math.Ceiling(bv.X));
 
-                 // Интерполяция между крайними точками
-                 var step = bv.X - av.X;
-                 var k = (step != 0) ? 1.0f / step : 0;
+                // Интерполяция между крайними точками
+                var step = bv.X - av.X;
+                var k = (step != 0) ? 1.0f / step : 0;
 
-                 for (int x = left; x < right; x++)
-                 {
-                     var t = (x - av.X) * k;
+                for (int x = left; x < right; x++)
+                {
+                    var t = (x - av.X) * k;
 
-                     // Интерполируем Z
-                     var z = av.Z + (bv.Z - av.Z) * t;
+                    // Интерполируем Z
+                    var z = av.Z + (bv.Z - av.Z) * t;
 
-                    // Интерполируем нормаль
-                    //var normal = Vector3.Normalize(an + (bn - an) * t);
+                   // Интерполируем нормаль
+                   //var normal = Vector3.Normalize(an + (bn - an) * t);
 
-                    // Интерполируем UV
-                    //var uv = auv + (buv - auv) * t;
+                   // Интерполируем UV
+                   //var uv = auv + (buv - auv) * t;
 
 
-                    var auv_div_z = auv / av.Z;  // uv0 / z0
-                    var buv_div_z = buv / bv.Z;  // uv1 / z1
-                    var a_inv_z = 1.0f / av.Z;   // 1 / z0
-                    var b_inv_z = 1.0f / bv.Z;   // 1 / z1
+                   var auv_div_z = auv / av.Z;  // uv0 / z0
+                   var buv_div_z = buv / bv.Z;  // uv1 / z1
+                   var a_inv_z = 1.0f / av.Z;   // 1 / z0
+                   var b_inv_z = 1.0f / bv.Z;   // 1 / z1
 
-                    // 2. Линейно интерполируем (uv/z) и (1/z)
-                    var uv_div_z_interp = auv_div_z + (buv_div_z - auv_div_z) * t;  // (1-t)*(uv0/z0) + t*(uv1/z1)
-                    var inv_z_interp = a_inv_z + (b_inv_z - a_inv_z) * t;           // (1-t)*(1/z0) + t*(1/z1)
+                   // 2. Линейно интерполируем (uv/z) и (1/z)
+                   var uv_div_z_interp = auv_div_z + (buv_div_z - auv_div_z) * t;  // (1-t)*(uv0/z0) + t*(uv1/z1)
+                   var inv_z_interp = a_inv_z + (b_inv_z - a_inv_z) * t;           // (1-t)*(1/z0) + t*(1/z1)
 
-                    // 3. Восстанавливаем uv: uv = (uv/z) / (1/z)
-                    var uv = uv_div_z_interp / inv_z_interp;
+                   // 3. Восстанавливаем uv: uv = (uv/z) / (1/z)
+                   var uv = uv_div_z_interp / inv_z_interp;
 
-                    // Получаем цвет из текстуры
-                    var texColor = GetTextureColor(model.DiffuseMap, uv.X, uv.Y);
+                   // Получаем цвет из текстуры
+                   var texColor = GetTextureColor(model.DiffuseMap, uv.X, uv.Y);
 
-                     // Используем цвет текстуры как kd и ka
-                     var Ka = new Vector3(texColor.R / 255f, texColor.G / 255f, texColor.B / 255f);
-                     var Kd = Ka; // Обычно диффузная карта используется и для kd и для ka
+                    // Используем цвет текстуры как kd и ka
+                    var Ka = new Vector3(texColor.R / 255f, texColor.G / 255f, texColor.B / 255f);
+                    var Kd = Ka; // Обычно диффузная карта используется и для kd и для ka
 
-                     var normalFromMap = GetNormalFromMap(model.NormalMap, uv.X, uv.Y);
+                    var normalFromMap = GetNormalFromMap(model.NormalMap, uv.X, uv.Y);
 
-                     // Преобразуем нормаль из [0,1] в [-1,1] и нормализуем
-                     var normal = Vector3.Normalize(normalFromMap * 2 - Vector3.One);
+                    // Преобразуем нормаль из [0,1] в [-1,1] и нормализуем
+                    var normal = Vector3.Normalize(normalFromMap * 2 - Vector3.One);
 
-                     // Вычисляем цвет по Фонгу с учетом текстуры
-                     var color = CalculatePhongColor(
-                         new Vector4(x, y, z, 1),
-                         normal,
-                         model.lightDir,
-                         model.target,
-                         Ka,
-                         Kd,
-                         model.Ks,
-                         model.Shininess,
-                         model.lightColor);
+                    // Вычисляем цвет по Фонгу с учетом текстуры
+                    var color = CalculatePhongColor(
+                        new Vector4(x, y, z, 1),
+                        normal,
+                        model.lightDir,
+                        model.target,
+                        Ka,
+                        Kd,
+                        model.Ks,
+                        model.Shininess,
+                        model.lightColor);
 
-                     // Применяем основной цвет объекта
-                     color = Color.FromArgb(
-                         (int)(color.B * this.B / 255),
-                         (int)(color.G * this.G / 255),
-                         (int)(color.R * this.R / 255));
+                    // Применяем основной цвет объекта
+                    color = Color.FromArgb(
+                        (int)(color.B * this.B / 255),
+                        (int)(color.G * this.G / 255),
+                        (int)(color.R * this.R / 255));
 
-                     if (_buffer.PutZValue(x, y, z))
-                         _buffer[x, y] = color;
-                 }
-             }
-         }
+                    if (_buffer.PutZValue(x, y, z))
+                        _buffer[x, y] = color;
+                }
+            }
+        }
 
-         private Color GetTextureColor(Bitmap texture, float u, float v)
-         {
-             // Обеспечиваем повторение текстуры (tiling)
-             u = u - (float)Math.Floor(u);
-             v = v - (float)Math.Floor(v);
+        private Color GetTextureColor(Bitmap texture, float u, float v)
+        {
+            // Обеспечиваем повторение текстуры (tiling)
+            u = u - (float)Math.Floor(u);
+            v = v - (float)Math.Floor(v);
 
-             // Преобразуем UV в координаты текстуры
-             int x = (int)(u * (texture.Width - 1));
-             int y = (int)((1 - v) * (texture.Height - 1)); // Инвертируем V
+            // Преобразуем UV в координаты текстуры
+            int x = (int)(u * (texture.Width - 1));
+            int y = (int)((1 - v) * (texture.Height - 1)); // Инвертируем V
 
-             // Получаем цвет текстуры
-             return texture.GetPixel(x, y);
-         }
+            // Получаем цвет текстуры
+            return texture.GetPixel(x, y);
+        }
 
-         private Vector3 GetNormalFromMap(Bitmap normalMap, float u, float v)
-         {
-             // Обеспечиваем повторение текстуры (tiling)
-             u = u - (float)Math.Floor(u);
-             v = v - (float)Math.Floor(v);
+        private Vector3 GetNormalFromMap(Bitmap normalMap, float u, float v)
+        {
+            // Обеспечиваем повторение текстуры (tiling)
+            u = u - (float)Math.Floor(u);
+            v = v - (float)Math.Floor(v);
 
-             // Преобразуем UV в координаты текстуры
-             int x = (int)(u * (normalMap.Width - 1));
-             int y = (int)((1 - v) * (normalMap.Height - 1)); // Инвертируем V
+            // Преобразуем UV в координаты текстуры
+            int x = (int)(u * (normalMap.Width - 1));
+            int y = (int)((1 - v) * (normalMap.Height - 1)); // Инвертируем V
 
-             // Получаем цвет из карты нормалей
-             var color = normalMap.GetPixel(x, y);
+            // Получаем цвет из карты нормалей
+            var color = normalMap.GetPixel(x, y);
 
-             // Преобразуем цвет в вектор нормали (значения в [0,1])
-             return new Vector3(
-                 color.R / 255f,
-                 color.G / 255f,
-                 color.B / 255f);
-         }
-         #endregion*/
+            // Преобразуем цвет в вектор нормали (значения в [0,1])
+            return new Vector3(
+                color.R / 255f,
+                color.G / 255f,
+                color.B / 255f);
+        }
+        #endregion*/
     }
 }
\ No newline at end of file
Index: Realization/Elements/Model.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Numerics;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nusing static System.Math;\r\nusing AKG.Realization;\r\n\r\n\r\nnamespace AKG.Realization.Elements\r\n{\r\n    public class Model\r\n    {\r\n        private readonly List<Vector4> _modelVertices;\r\n        private readonly List<Vector4> _worldVertices;\r\n        private readonly List<Vector4> _viewVertices;\r\n        private readonly List<Vector4> _perspectiveVertices;\r\n        private readonly List<Vector4> _viewportVertices;\r\n        private readonly List<Vector3> _modelTextureCoordinates;\r\n        private readonly List<Normal> _modelNormals;\r\n        private readonly List<Face> _modelFaces;\r\n\r\n        public float ShiftX { get; set; } = 0;\r\n        public float ShiftY { get; set; } = 0;\r\n        public float ShiftZ { get; set; } = 0;\r\n\r\n        public float RotationOfXInRadians { get; set; }\r\n        public float RotationOfYInRadians { get; set; }\r\n        public float RotationOfZInRadians { get; set; } = 0;\r\n\r\n        public float Scale { get; set; } = 0.005f;\r\n\r\n        public Vector3 Ka { get; set; }//фоновое\r\n        public Vector3 Kd { get; set; }//рассеяное\r\n        public Vector3 Ks { get; set; }//зеркальное\r\n        public float Shininess { get; set; } // коэф блеска\r\n\r\n        public Vector3 lightColor { get; set; } = new Vector3(0.9f, 0.9f, 0.9f);\r\n\r\n        public Bitmap DiffuseMap { get; set; } = new Bitmap(\"../../../Models/diffuse-maps/bricks.jpg\");\r\n        public Bitmap NormalMap { get; set; } = new Bitmap(\"../../../Models/normal-maps/bricks.png\");\r\n        public Bitmap SpecularMap { get; set; } = new Bitmap(\"../../../Models/specular-maps/bricks.jpg\");\r\n        public void setDefaultMaterial()\r\n        {\r\n            this.Ka = new Vector3(0.1f, 0.1f, 0.1f);\r\n            this.Kd = new Vector3(0.9f, 0.9f, 0.9f);\r\n            this.Ks = new Vector3(0.5f, 0.5f, 0.5f);\r\n            this.Shininess = 32f;\r\n        }\r\n\r\n        public Vector3 eye;\r\n        public Vector3 target;\r\n        public Vector3 up;\r\n        public Vector3 lightDir = new Vector3(0, -1, 0);\r\n        public float zFar = 100;\r\n        public float zNear;\r\n        public float Fov = (float)(20 * PI / 180);\r\n\r\n        public Model(List<Vector4> modelVertices, List<Vector3> modelTextureCoordinates,\r\n            List<Normal> modelNormals,\r\n            List<Face> modelFaces)\r\n        {\r\n            _modelVertices = modelVertices;\r\n            _modelTextureCoordinates = modelTextureCoordinates;\r\n            _modelNormals = modelNormals;\r\n            _modelFaces = modelFaces;\r\n            _worldVertices = new(modelVertices);\r\n            _viewVertices = new(modelVertices);\r\n            _perspectiveVertices = new(modelVertices);\r\n            _viewportVertices = new(modelVertices);\r\n        }\r\n\r\n        public void UpdateModelInfo(Vector3 eye, Vector3 target, Vector3 up)\r\n        {\r\n            this.eye = eye;\r\n            this.target = target;\r\n            this.up = up;\r\n        }\r\n\r\n        public List<Vector4> GetModelVertices() => _modelVertices;\r\n        public List<Vector4> GetWorldVertices() => _worldVertices;\r\n        public List<Vector4> GetViewPortVertices() => _viewportVertices;\r\n        public List<Vector3> GetModelTextureCoordinates() => _modelTextureCoordinates;\r\n        public List<Normal> GetModelNormals() => _modelNormals;\r\n        public List<Face> GetModelFaces() => _modelFaces;\r\n\r\n\r\n        public void CalculateVertices(int width, int height)\r\n        {\r\n            float aspect = width / (float)height;\r\n            zNear = width;\r\n\r\n            var res = Parallel.For(0, _modelVertices.Count, i =>\r\n            {\r\n                _worldVertices[i] = MatrixTransformations.TransformToWordMatrix(_modelVertices[i], ShiftX, ShiftY,\r\n                    ShiftZ,\r\n                    RotationOfXInRadians, RotationOfYInRadians, RotationOfZInRadians, Scale);\r\n                _viewVertices[i] = MatrixTransformations.TransformToViewMatrix(_worldVertices[i], eye, target, up);\r\n                _perspectiveVertices[i] = MatrixTransformations.TransformToPerspectiveProjectionMatrix(\r\n                    _viewVertices[i], Fov, aspect, zNear, zFar);\r\n                _viewportVertices[i] =\r\n                    MatrixTransformations.TransformToViewportMatrix(_perspectiveVertices[i], width, height, 0, 0);\r\n            });\r\n        }\r\n        private List<Vector2> _modelTextureCoordinates2;\r\n        public List<Vector2> GetTextureCoords()\r\n        {\r\n           \r\n            // Если есть явные текстурные координаты, возвращаем их\r\n            if (_modelTextureCoordinates != null && _modelTextureCoordinates.Count > 0)\r\n            {\r\n                List<Vector2> _modelTextureCoordinates2 = new List<Vector2>();\r\n                foreach (Vector3 v in  _modelTextureCoordinates)\r\n                    _modelTextureCoordinates2.Add(new Vector2(v.X, v.Y));\r\n                return _modelTextureCoordinates2;\r\n            }\r\n\r\n            // Если нет - создаем список, где каждая вершина имеет UV-координаты\r\n            var textureCoords = new List<Vector2>(_modelVertices.Count);\r\n\r\n            // Вычисляем bounding box модели\r\n            float minX = float.MaxValue, maxX = float.MinValue;\r\n            float minY = float.MaxValue, maxY = float.MinValue;\r\n            float minZ = float.MaxValue, maxZ = float.MinValue;\r\n\r\n            foreach (var vertex in _modelVertices)\r\n            {\r\n                minX = Math.Min(minX, vertex.X);\r\n                maxX = Math.Max(maxX, vertex.X);\r\n                minY = Math.Min(minY, vertex.Y);\r\n                maxY = Math.Max(maxY, vertex.Y);\r\n                minZ = Math.Min(minZ, vertex.Z);\r\n                maxZ = Math.Max(maxZ, vertex.Z);\r\n            }\r\n\r\n            // Генерируем UV-координаты на основе положения вершин\r\n            foreach (var vertex in _modelVertices)\r\n            {\r\n                // Нормализуем координаты к [0, 1] диапазону\r\n                float u = (vertex.X - minX) / (maxX - minX);\r\n                float v = (vertex.Y - minY) / (maxY - minY);\r\n\r\n                // Альтернативный вариант - сферические координаты\r\n                // Vector3 normal = new Vector3(vertex.X, vertex.Y, vertex.Z);\r\n                // normal = Vector3.Normalize(normal);\r\n                // float u = 0.5f + (float)(Atan2(normal.Z, normal.X) / (2 * PI));\r\n                // float v = 0.5f - (float)(Asin(normal.Y) / PI);\r\n\r\n                textureCoords.Add(new Vector2(u, v));\r\n            }\r\n\r\n            return textureCoords;\r\n        }\r\n        public List<Vector3> GetNormals()\r\n        {\r\n\r\n            // Если нормалей нет, вычисляем их как усредненные нормали смежных граней\r\n            var vertexNormals = new Dictionary<int, Vector3>();\r\n            var vertexToFaces = new Dictionary<int, List<Vector3>>();\r\n\r\n            // Собираем все грани, связанные с каждой вершиной\r\n            foreach (var face in _modelFaces)\r\n            {\r\n                var v0 = face.Indices[0].VertexIndex - 1;\r\n                var v1 = face.Indices[1].VertexIndex - 1;\r\n                var v2 = face.Indices[2].VertexIndex - 1;\r\n\r\n                // Вычисляем нормаль текущей грани\r\n                var edge1 = _modelVertices[v1] - _modelVertices[v0];\r\n                var edge2 = _modelVertices[v2] - _modelVertices[v0];\r\n                var faceNormal = Vector3.Normalize(Vector3.Cross(\r\n                    new Vector3(edge1.X, edge1.Y, edge1.Z),\r\n                    new Vector3(edge2.X, edge2.Y, edge2.Z)));\r\n\r\n                // Добавляем нормаль грани к каждой вершине\r\n                for (int i = 0; i < 3; i++)\r\n                {\r\n                    var vertexIndex = face.Indices[i].VertexIndex - 1;\r\n                    if (!vertexToFaces.ContainsKey(vertexIndex))\r\n                        vertexToFaces[vertexIndex] = new List<Vector3>();\r\n                    vertexToFaces[vertexIndex].Add(faceNormal);\r\n                }\r\n            }\r\n\r\n            // Усредняем нормали для каждой вершины\r\n            var normals = new List<Vector3>(_modelVertices.Count);\r\n            for (int i = 0; i < _modelVertices.Count; i++)\r\n            {\r\n                if (vertexToFaces.TryGetValue(i, out var faceNormals))\r\n                {\r\n                    var avgNormal = Vector3.Zero;\r\n                    foreach (var normal in faceNormals)\r\n                        avgNormal += normal;\r\n                    normals.Add(Vector3.Normalize(avgNormal));\r\n                }\r\n                else\r\n                {\r\n                    normals.Add(Vector3.UnitZ); // Дефолтная нормаль, если вершина не используется\r\n                }\r\n            }\r\n\r\n            return normals;\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Realization/Elements/Model.cs b/Realization/Elements/Model.cs
--- a/Realization/Elements/Model.cs	(revision dc8ea09344de44f0ccb8d230f234d3119f4cf238)
+++ b/Realization/Elements/Model.cs	(date 1745507387810)
@@ -18,7 +18,7 @@
         private readonly List<Vector4> _perspectiveVertices;
         private readonly List<Vector4> _viewportVertices;
         private readonly List<Vector3> _modelTextureCoordinates;
-        private readonly List<Normal> _modelNormals;
+        private readonly List<Vector3> _modelNormals;
         private readonly List<Face> _modelFaces;
 
         public float ShiftX { get; set; } = 0;
@@ -38,9 +38,9 @@
 
         public Vector3 lightColor { get; set; } = new Vector3(0.9f, 0.9f, 0.9f);
 
-        public Bitmap DiffuseMap { get; set; } = new Bitmap("../../../Models/diffuse-maps/bricks.jpg");
-        public Bitmap NormalMap { get; set; } = new Bitmap("../../../Models/normal-maps/bricks.png");
-        public Bitmap SpecularMap { get; set; } = new Bitmap("../../../Models/specular-maps/bricks.jpg");
+        public Bitmap DiffuseMap { get; set; } = new Bitmap("../../../Models/diffuse-maps/craneo.jpg");
+        public Bitmap NormalMap { get; set; } = new Bitmap("../../../Models/normal-maps/craneo2.png");
+        public Bitmap SpecularMap { get; set; } = new Bitmap("../../../Models/specular-maps/craneo.jpg");
         public void setDefaultMaterial()
         {
             this.Ka = new Vector3(0.1f, 0.1f, 0.1f);
@@ -58,7 +58,7 @@
         public float Fov = (float)(20 * PI / 180);
 
         public Model(List<Vector4> modelVertices, List<Vector3> modelTextureCoordinates,
-            List<Normal> modelNormals,
+            List<Vector3> modelNormals,
             List<Face> modelFaces)
         {
             _modelVertices = modelVertices;
@@ -82,7 +82,7 @@
         public List<Vector4> GetWorldVertices() => _worldVertices;
         public List<Vector4> GetViewPortVertices() => _viewportVertices;
         public List<Vector3> GetModelTextureCoordinates() => _modelTextureCoordinates;
-        public List<Normal> GetModelNormals() => _modelNormals;
+        public List<Vector3> GetModelNormals() => _modelNormals;
         public List<Face> GetModelFaces() => _modelFaces;
 
 
Index: obj/Debug/net8.0-windows/AKG.AssemblyInfo.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//------------------------------------------------------------------------------\r\n// <auto-generated>\r\n//     Этот код создан программой.\r\n//     Исполняемая версия:4.0.30319.42000\r\n//\r\n//     Изменения в этом файле могут привести к неправильной работе и будут потеряны в случае\r\n//     повторной генерации кода.\r\n// </auto-generated>\r\n//------------------------------------------------------------------------------\r\n\r\nusing System;\r\nusing System.Reflection;\r\n\r\n[assembly: System.Reflection.AssemblyCompanyAttribute(\"AKG\")]\r\n[assembly: System.Reflection.AssemblyConfigurationAttribute(\"Debug\")]\r\n[assembly: System.Reflection.AssemblyFileVersionAttribute(\"1.0.0.0\")]\r\n[assembly: System.Reflection.AssemblyInformationalVersionAttribute(\"1.0.0+c4d9141b3dd5c31f54b0e85fff4512325a792af1\")]\r\n[assembly: System.Reflection.AssemblyProductAttribute(\"AKG\")]\r\n[assembly: System.Reflection.AssemblyTitleAttribute(\"AKG\")]\r\n[assembly: System.Reflection.AssemblyVersionAttribute(\"1.0.0.0\")]\r\n[assembly: System.Runtime.Versioning.TargetPlatformAttribute(\"Windows7.0\")]\r\n[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute(\"Windows7.0\")]\r\n\r\n// Создано классом WriteCodeFragment MSBuild.\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/obj/Debug/net8.0-windows/AKG.AssemblyInfo.cs b/obj/Debug/net8.0-windows/AKG.AssemblyInfo.cs
--- a/obj/Debug/net8.0-windows/AKG.AssemblyInfo.cs	(revision dc8ea09344de44f0ccb8d230f234d3119f4cf238)
+++ b/obj/Debug/net8.0-windows/AKG.AssemblyInfo.cs	(date 1745507345404)
@@ -1,10 +1,9 @@
 //------------------------------------------------------------------------------
 // <auto-generated>
-//     Этот код создан программой.
-//     Исполняемая версия:4.0.30319.42000
+//     This code was generated by a tool.
 //
-//     Изменения в этом файле могут привести к неправильной работе и будут потеряны в случае
-//     повторной генерации кода.
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
 // </auto-generated>
 //------------------------------------------------------------------------------
 
@@ -14,7 +13,7 @@
 [assembly: System.Reflection.AssemblyCompanyAttribute("AKG")]
 [assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
 [assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
-[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+c4d9141b3dd5c31f54b0e85fff4512325a792af1")]
+[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+dc8ea09344de44f0ccb8d230f234d3119f4cf238")]
 [assembly: System.Reflection.AssemblyProductAttribute("AKG")]
 [assembly: System.Reflection.AssemblyTitleAttribute("AKG")]
 [assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
Index: obj/Debug/net8.0-windows/AKG.GeneratedMSBuildEditorConfig.editorconfig
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>is_global = true\r\nbuild_property.ApplicationManifest = \r\nbuild_property.StartupObject = \r\nbuild_property.ApplicationDefaultFont = \r\nbuild_property.ApplicationHighDpiMode = \r\nbuild_property.ApplicationUseCompatibleTextRendering = \r\nbuild_property.ApplicationVisualStyles = \r\nbuild_property.TargetFramework = net8.0-windows\r\nbuild_property.TargetPlatformMinVersion = 7.0\r\nbuild_property.UsingMicrosoftNETSdkWeb = \r\nbuild_property.ProjectTypeGuids = \r\nbuild_property.InvariantGlobalization = \r\nbuild_property.PlatformNeutralAssembly = \r\nbuild_property.EnforceExtendedAnalyzerRules = \r\nbuild_property._SupportedPlatformList = Linux,macOS,Windows\r\nbuild_property.RootNamespace = AKG\r\nbuild_property.ProjectDir = E:\\6sem\\AkgGit\\AKG\\AKG\\\r\nbuild_property.EnableComHosting = \r\nbuild_property.EnableGeneratedComInterfaceComImportInterop = \r\nbuild_property.CsWinRTUseWindowsUIXamlProjections = false\r\nbuild_property.EffectiveAnalysisLevelStyle = 8.0\r\nbuild_property.EnableCodeStyleSeverity = \r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/obj/Debug/net8.0-windows/AKG.GeneratedMSBuildEditorConfig.editorconfig b/obj/Debug/net8.0-windows/AKG.GeneratedMSBuildEditorConfig.editorconfig
--- a/obj/Debug/net8.0-windows/AKG.GeneratedMSBuildEditorConfig.editorconfig	(revision dc8ea09344de44f0ccb8d230f234d3119f4cf238)
+++ b/obj/Debug/net8.0-windows/AKG.GeneratedMSBuildEditorConfig.editorconfig	(date 1745507223450)
@@ -14,7 +14,7 @@
 build_property.EnforceExtendedAnalyzerRules = 
 build_property._SupportedPlatformList = Linux,macOS,Windows
 build_property.RootNamespace = AKG
-build_property.ProjectDir = E:\6sem\AkgGit\AKG\AKG\
+build_property.ProjectDir = C:\BSUIR\AKGv2\AKG\
 build_property.EnableComHosting = 
 build_property.EnableGeneratedComInterfaceComImportInterop = 
 build_property.CsWinRTUseWindowsUIXamlProjections = false
Index: obj/rider.project.model.nuget.info
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>17446411195238057
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/obj/rider.project.model.nuget.info b/obj/rider.project.model.nuget.info
--- a/obj/rider.project.model.nuget.info	(revision dc8ea09344de44f0ccb8d230f234d3119f4cf238)
+++ b/obj/rider.project.model.nuget.info	(date 1747219474088)
@@ -1,1 +1,1 @@
-17446411195238057
\ No newline at end of file
+17455073544632676
\ No newline at end of file
Index: obj/rider.project.restore.info
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>17446411195238057
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/obj/rider.project.restore.info b/obj/rider.project.restore.info
--- a/obj/rider.project.restore.info	(revision dc8ea09344de44f0ccb8d230f234d3119f4cf238)
+++ b/obj/rider.project.restore.info	(date 1747219474648)
@@ -1,1 +1,1 @@
-17446411195238057
\ No newline at end of file
+17455073544632676
\ No newline at end of file
Index: obj/Debug/net8.0-windows/AKG.sourcelink.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>{\"documents\":{\"E:\\\\6sem\\\\AkgGit\\\\AKG\\\\*\":\"https://raw.githubusercontent.com/nastenka-ooops/AKG/c4d9141b3dd5c31f54b0e85fff4512325a792af1/*\"}}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/obj/Debug/net8.0-windows/AKG.sourcelink.json b/obj/Debug/net8.0-windows/AKG.sourcelink.json
--- a/obj/Debug/net8.0-windows/AKG.sourcelink.json	(revision dc8ea09344de44f0ccb8d230f234d3119f4cf238)
+++ b/obj/Debug/net8.0-windows/AKG.sourcelink.json	(date 1745507356679)
@@ -1,1 +1,1 @@
-{"documents":{"E:\\6sem\\AkgGit\\AKG\\*":"https://raw.githubusercontent.com/nastenka-ooops/AKG/c4d9141b3dd5c31f54b0e85fff4512325a792af1/*"}}
\ No newline at end of file
+{"documents":{"C:\\BSUIR\\AKGv2\\*":"https://raw.githubusercontent.com/nastenka-ooops/AKG/dc8ea09344de44f0ccb8d230f234d3119f4cf238/*"}}
\ No newline at end of file
Index: obj/AKG.csproj.nuget.dgspec.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>{\r\n  \"format\": 1,\r\n  \"restore\": {\r\n    \"E:\\\\6sem\\\\AkgGit\\\\AKG\\\\AKG\\\\AKG.csproj\": {}\r\n  },\r\n  \"projects\": {\r\n    \"E:\\\\6sem\\\\AkgGit\\\\AKG\\\\AKG\\\\AKG.csproj\": {\r\n      \"version\": \"1.0.0\",\r\n      \"restore\": {\r\n        \"projectUniqueName\": \"E:\\\\6sem\\\\AkgGit\\\\AKG\\\\AKG\\\\AKG.csproj\",\r\n        \"projectName\": \"AKG\",\r\n        \"projectPath\": \"E:\\\\6sem\\\\AkgGit\\\\AKG\\\\AKG\\\\AKG.csproj\",\r\n        \"packagesPath\": \"C:\\\\Users\\\\Kangaschan\\\\.nuget\\\\packages\\\\\",\r\n        \"outputPath\": \"E:\\\\6sem\\\\AkgGit\\\\AKG\\\\AKG\\\\obj\\\\\",\r\n        \"projectStyle\": \"PackageReference\",\r\n        \"fallbackFolders\": [\r\n          \"C:\\\\Program Files (x86)\\\\Microsoft Visual Studio\\\\Shared\\\\NuGetPackages\"\r\n        ],\r\n        \"configFilePaths\": [\r\n          \"C:\\\\Users\\\\Kangaschan\\\\AppData\\\\Roaming\\\\NuGet\\\\NuGet.Config\",\r\n          \"C:\\\\Program Files (x86)\\\\NuGet\\\\Config\\\\Microsoft.VisualStudio.FallbackLocation.config\",\r\n          \"C:\\\\Program Files (x86)\\\\NuGet\\\\Config\\\\Microsoft.VisualStudio.Offline.config\"\r\n        ],\r\n        \"originalTargetFrameworks\": [\r\n          \"net8.0-windows\"\r\n        ],\r\n        \"sources\": {\r\n          \"C:\\\\Program Files (x86)\\\\Microsoft SDKs\\\\NuGetPackages\\\\\": {},\r\n          \"C:\\\\Program Files\\\\dotnet\\\\library-packs\": {},\r\n          \"https://api.nuget.org/v3/index.json\": {}\r\n        },\r\n        \"frameworks\": {\r\n          \"net8.0-windows7.0\": {\r\n            \"targetAlias\": \"net8.0-windows\",\r\n            \"projectReferences\": {}\r\n          }\r\n        },\r\n        \"warningProperties\": {\r\n          \"warnAsError\": [\r\n            \"NU1605\"\r\n          ]\r\n        },\r\n        \"restoreAuditProperties\": {\r\n          \"enableAudit\": \"true\",\r\n          \"auditLevel\": \"low\",\r\n          \"auditMode\": \"direct\"\r\n        },\r\n        \"SdkAnalysisLevel\": \"9.0.200\"\r\n      },\r\n      \"frameworks\": {\r\n        \"net8.0-windows7.0\": {\r\n          \"targetAlias\": \"net8.0-windows\",\r\n          \"imports\": [\r\n            \"net461\",\r\n            \"net462\",\r\n            \"net47\",\r\n            \"net471\",\r\n            \"net472\",\r\n            \"net48\",\r\n            \"net481\"\r\n          ],\r\n          \"assetTargetFallback\": true,\r\n          \"warn\": true,\r\n          \"frameworkReferences\": {\r\n            \"Microsoft.NETCore.App\": {\r\n              \"privateAssets\": \"all\"\r\n            },\r\n            \"Microsoft.WindowsDesktop.App.WindowsForms\": {\r\n              \"privateAssets\": \"none\"\r\n            }\r\n          },\r\n          \"runtimeIdentifierGraphPath\": \"C:\\\\Program Files\\\\dotnet\\\\sdk\\\\9.0.203/PortableRuntimeIdentifierGraph.json\"\r\n        }\r\n      }\r\n    }\r\n  }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/obj/AKG.csproj.nuget.dgspec.json b/obj/AKG.csproj.nuget.dgspec.json
--- a/obj/AKG.csproj.nuget.dgspec.json	(revision dc8ea09344de44f0ccb8d230f234d3119f4cf238)
+++ b/obj/AKG.csproj.nuget.dgspec.json	(date 1745507354463)
@@ -1,32 +1,29 @@
 {
   "format": 1,
   "restore": {
-    "E:\\6sem\\AkgGit\\AKG\\AKG\\AKG.csproj": {}
+    "C:\\BSUIR\\AKGv2\\AKG\\AKG.csproj": {}
   },
   "projects": {
-    "E:\\6sem\\AkgGit\\AKG\\AKG\\AKG.csproj": {
+    "C:\\BSUIR\\AKGv2\\AKG\\AKG.csproj": {
       "version": "1.0.0",
       "restore": {
-        "projectUniqueName": "E:\\6sem\\AkgGit\\AKG\\AKG\\AKG.csproj",
+        "projectUniqueName": "C:\\BSUIR\\AKGv2\\AKG\\AKG.csproj",
         "projectName": "AKG",
-        "projectPath": "E:\\6sem\\AkgGit\\AKG\\AKG\\AKG.csproj",
-        "packagesPath": "C:\\Users\\Kangaschan\\.nuget\\packages\\",
-        "outputPath": "E:\\6sem\\AkgGit\\AKG\\AKG\\obj\\",
+        "projectPath": "C:\\BSUIR\\AKGv2\\AKG\\AKG.csproj",
+        "packagesPath": "C:\\Users\\Admin\\.nuget\\packages\\",
+        "outputPath": "C:\\BSUIR\\AKGv2\\AKG\\obj\\",
         "projectStyle": "PackageReference",
         "fallbackFolders": [
           "C:\\Program Files (x86)\\Microsoft Visual Studio\\Shared\\NuGetPackages"
         ],
         "configFilePaths": [
-          "C:\\Users\\Kangaschan\\AppData\\Roaming\\NuGet\\NuGet.Config",
-          "C:\\Program Files (x86)\\NuGet\\Config\\Microsoft.VisualStudio.FallbackLocation.config",
-          "C:\\Program Files (x86)\\NuGet\\Config\\Microsoft.VisualStudio.Offline.config"
+          "C:\\Users\\Admin\\AppData\\Roaming\\NuGet\\NuGet.Config",
+          "C:\\Program Files (x86)\\NuGet\\Config\\Microsoft.VisualStudio.FallbackLocation.config"
         ],
         "originalTargetFrameworks": [
           "net8.0-windows"
         ],
         "sources": {
-          "C:\\Program Files (x86)\\Microsoft SDKs\\NuGetPackages\\": {},
-          "C:\\Program Files\\dotnet\\library-packs": {},
           "https://api.nuget.org/v3/index.json": {}
         },
         "frameworks": {
@@ -45,7 +42,7 @@
           "auditLevel": "low",
           "auditMode": "direct"
         },
-        "SdkAnalysisLevel": "9.0.200"
+        "SdkAnalysisLevel": "9.0.100"
       },
       "frameworks": {
         "net8.0-windows7.0": {
@@ -61,6 +58,24 @@
           ],
           "assetTargetFallback": true,
           "warn": true,
+          "downloadDependencies": [
+            {
+              "name": "Microsoft.AspNetCore.App.Ref",
+              "version": "[8.0.12, 8.0.12]"
+            },
+            {
+              "name": "Microsoft.NETCore.App.Host.win-x64",
+              "version": "[8.0.12, 8.0.12]"
+            },
+            {
+              "name": "Microsoft.NETCore.App.Ref",
+              "version": "[8.0.12, 8.0.12]"
+            },
+            {
+              "name": "Microsoft.WindowsDesktop.App.Ref",
+              "version": "[8.0.12, 8.0.12]"
+            }
+          ],
           "frameworkReferences": {
             "Microsoft.NETCore.App": {
               "privateAssets": "all"
@@ -69,7 +84,7 @@
               "privateAssets": "none"
             }
           },
-          "runtimeIdentifierGraphPath": "C:\\Program Files\\dotnet\\sdk\\9.0.203/PortableRuntimeIdentifierGraph.json"
+          "runtimeIdentifierGraphPath": "C:\\Program Files\\dotnet\\sdk\\9.0.102/PortableRuntimeIdentifierGraph.json"
         }
       }
     }
Index: .idea/.idea.AKG/.idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoGeneratedRunConfigurationManager\">\r\n    <projectFile>AKG/AKG.csproj</projectFile>\r\n  </component>\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"dd0a393e-b8c6-4340-bc02-58324722a279\" name=\"Changes\" comment=\"\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/.idea.AKG/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/.idea.AKG/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/AKG.sln.DotSettings.user\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/AKG.sln.DotSettings.user\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/Drawing/BuffBitmap.cs\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Drawing/BuffBitmap.cs\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/Drawing/Painter.cs\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Drawing/Painter.cs\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/MainForm.cs\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/MainForm.cs\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/Models/craneo.OBJ\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/Realization/Elements/Model.cs\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Realization/Elements/Model.cs\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/Realization/ObjParaser.cs\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Realization/ObjParaser.cs\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/bin/Debug/net8.0-windows/AKG.dll\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/bin/Debug/net8.0-windows/AKG.dll\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/bin/Debug/net8.0-windows/AKG.exe\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/bin/Debug/net8.0-windows/AKG.exe\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/bin/Debug/net8.0-windows/AKG.pdb\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/bin/Debug/net8.0-windows/AKG.pdb\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/bin/Debug/net8.0-windows/AKG.runtimeconfig.json\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/bin/Debug/net8.0-windows/AKG.runtimeconfig.json\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/bin/Debug/net8.0-windows/tmp.png\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/bin/Debug/net8.0-windows/tmp.png\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/obj/AKG.csproj.nuget.dgspec.json\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/obj/AKG.csproj.nuget.dgspec.json\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/obj/AKG.csproj.nuget.g.props\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/obj/AKG.csproj.nuget.g.props\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/obj/Debug/net8.0-windows/AKG.AssemblyInfo.cs\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/obj/Debug/net8.0-windows/AKG.AssemblyInfo.cs\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/obj/Debug/net8.0-windows/AKG.AssemblyInfoInputs.cache\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/obj/Debug/net8.0-windows/AKG.AssemblyInfoInputs.cache\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/obj/Debug/net8.0-windows/AKG.GeneratedMSBuildEditorConfig.editorconfig\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/obj/Debug/net8.0-windows/AKG.GeneratedMSBuildEditorConfig.editorconfig\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/obj/Debug/net8.0-windows/AKG.assets.cache\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/obj/Debug/net8.0-windows/AKG.assets.cache\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/obj/Debug/net8.0-windows/AKG.csproj.CoreCompileInputs.cache\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/obj/Debug/net8.0-windows/AKG.csproj.CoreCompileInputs.cache\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/obj/Debug/net8.0-windows/AKG.csproj.GenerateResource.cache\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/obj/Debug/net8.0-windows/AKG.csproj.GenerateResource.cache\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/obj/Debug/net8.0-windows/AKG.dll\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/obj/Debug/net8.0-windows/AKG.dll\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/obj/Debug/net8.0-windows/AKG.genruntimeconfig.cache\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/obj/Debug/net8.0-windows/AKG.genruntimeconfig.cache\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/obj/Debug/net8.0-windows/AKG.pdb\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/obj/Debug/net8.0-windows/AKG.pdb\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/obj/Debug/net8.0-windows/AKG.sourcelink.json\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/obj/Debug/net8.0-windows/AKG.sourcelink.json\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/obj/Debug/net8.0-windows/apphost.exe\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/obj/Debug/net8.0-windows/apphost.exe\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/obj/Debug/net8.0-windows/ref/AKG.dll\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/obj/Debug/net8.0-windows/ref/AKG.dll\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/obj/Debug/net8.0-windows/refint/AKG.dll\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/obj/Debug/net8.0-windows/refint/AKG.dll\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/obj/project.assets.json\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/obj/project.assets.json\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/obj/project.nuget.cache\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/obj/project.nuget.cache\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/obj/rider.project.model.nuget.info\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/obj/rider.project.model.nuget.info\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/obj/rider.project.restore.info\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/obj/rider.project.restore.info\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"DpaMonitoringSettings\">\r\n    <option name=\"firstShow\" value=\"false\" />\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$/..\" />\r\n    <option name=\"RESET_MODE\" value=\"HARD\" />\r\n  </component>\r\n  <component name=\"GitHubPullRequestSearchHistory\">{\r\n  &quot;lastFilter&quot;: {\r\n    &quot;state&quot;: &quot;OPEN&quot;,\r\n    &quot;assignee&quot;: &quot;nastenka-ooops&quot;\r\n  }\r\n}</component>\r\n  <component name=\"GithubPullRequestsUISettings\">{\r\n  &quot;selectedUrlAndAccountId&quot;: {\r\n    &quot;url&quot;: &quot;https://github.com/nastenka-ooops/AKG.git&quot;,\r\n    &quot;accountId&quot;: &quot;66d20223-d1fb-4ff5-8cbb-b7034013aec1&quot;\r\n  }\r\n}</component>\r\n  <component name=\"HighlightingSettingsPerFile\">\r\n    <setting file=\"file://$APPLICATION_CONFIG_DIR$/resharper-host/DecompilerCache/decompiler/1f2f0b08d2574f1aa35973d1cd0ae347cef920/17/9606b5a0/Control.cs\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"file://$APPLICATION_CONFIG_DIR$/resharper-host/DecompilerCache/decompiler/1f2f0b08d2574f1aa35973d1cd0ae347cef920/b6/b9864440/NativeWindow.cs\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"file://$APPLICATION_CONFIG_DIR$/resharper-host/DecompilerCache/decompiler/211e6f3b24fa438a92f1815153647ce2c8f908/8e/00790cc9/Vector3.cs\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"file://$APPLICATION_CONFIG_DIR$/resharper-host/DecompilerCache/decompiler/b6416db4533e4255bc43c1cfd556a910175930/47/1263af1a/Bitmap.cs\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"file://$APPLICATION_CONFIG_DIR$/resharper-host/DecompilerCache/decompiler/ef7e03ede4ac4f90a806cf587e874b52208a0/42/71813ca3/KnownColor.cs\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"file://$APPLICATION_CONFIG_DIR$/resharper-host/SourcesCache/261ea83c988816e3d8fe76b15b7ac6c10af64b8f9e739854f83c137c8ba9/SafeFileHandle.Windows.cs\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"file://$APPLICATION_CONFIG_DIR$/resharper-host/SourcesCache/2c8e7ca976f350cba9836d5565dac56b11e0b56656fa786460eb1395857a6fa/ThrowHelper.cs\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"file://$APPLICATION_CONFIG_DIR$/resharper-host/SourcesCache/6ef8e7d549f6bfb5b9eafaaa0ff48d8cbfc564f32be26323b5f60e63aef4dd1/SafeFileHandle.Windows.cs\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"file://$APPLICATION_CONFIG_DIR$/resharper-host/SourcesCache/72e5853ed6f2c1967eff9d6f0cf6ba12744c8978c516cbc5e74d992944ab/ArgumentOutOfRangeException.cs\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"file://$APPLICATION_CONFIG_DIR$/resharper-host/SourcesCache/ab9ab828d5fbbcad19820633b84af5d42a35924e6f5ce58ee698bca4522ad/Vector4.cs\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"file://$APPLICATION_CONFIG_DIR$/resharper-host/SourcesCache/b7208b3f72528d22781d25fde9a55271bdf2b5aade4f03b1324579a25493cd8/List.cs\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"file://$APPLICATION_CONFIG_DIR$/resharper-host/SourcesCache/c628921366b3915c1f443fdb5d3c1218593245e9f08e27a5b9f98c201220616d/Matrix4x4.Impl.cs\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"file://$APPLICATION_CONFIG_DIR$/resharper-host/SourcesCache/ca429a21c33085f75852201c3bd51fa8e65bf7d6ab5543339f23ad135f4c242/Math.cs\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"file://$APPLICATION_CONFIG_DIR$/resharper-host/SourcesCache/cbd9aa2e183e415276e47ce25bf4e2604cdb91cfaf74d6b3621074aad4605e62/Vector3.cs\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"file://$APPLICATION_CONFIG_DIR$/resharper-host/SourcesCache/ccba3091b5f4dba541c01e4c1f9556f026a274a39e7a51665aa3ac9a712e87/Color.cs\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"file://$APPLICATION_CONFIG_DIR$/resharper-host/SourcesCache/de7e5d9f3eff8e93316bbae6f9743ff9f72884862e5d612aaaba84bf9aa3a8/NativeWindow.cs\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"file://$APPLICATION_CONFIG_DIR$/resharper-host/SourcesCache/e68b3be647d57a34b98df1b515c4f8288fbace6ef9534c63ecaa6798fa3d4e2/Bitmap.cs\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"file://$APPLICATION_CONFIG_DIR$/resharper-host/SourcesCache/ed6aa59cd75423c5b655901d6ec4fb4be48ab669fa6fb01b3a7a7f31be95/Matrix4x4.cs\" root0=\"FORCE_HIGHLIGHTING\" />\r\n  </component>\r\n  <component name=\"KubernetesApiPersistence\">{}</component>\r\n  <component name=\"KubernetesApiProvider\">{\r\n  &quot;isMigrated&quot;: true\r\n}</component>\r\n  <component name=\"MetaFilesCheckinStateConfiguration\" checkMetaFiles=\"true\" />\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 5\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2tXz7Nh8fcA6MYBj36ZHZLGz4Gz\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\"><![CDATA[{\r\n  \"keyToString\": {\r\n    \".NET Project.AKG.executor\": \"Run\",\r\n    \"RunOnceActivity.ShowReadmeOnStart\": \"true\",\r\n    \"RunOnceActivity.git.unshallow\": \"true\",\r\n    \"git-widget-placeholder\": \"main\",\r\n    \"node.js.detected.package.eslint\": \"true\",\r\n    \"node.js.detected.package.tslint\": \"true\",\r\n    \"node.js.selected.package.eslint\": \"(autodetect)\",\r\n    \"node.js.selected.package.tslint\": \"(autodetect)\",\r\n    \"nodejs_package_manager_path\": \"npm\",\r\n    \"vue.rearranger.settings.migration\": \"true\"\r\n  }\r\n}]]></component>\r\n  <component name=\"RunManager\">\r\n    <configuration name=\"AKG\" type=\"DotNetProject\" factoryName=\".NET Project\">\r\n      <option name=\"EXE_PATH\" value=\"$PROJECT_DIR$/bin/Debug/net8.0-windows/AKG.dll\" />\r\n      <option name=\"PROGRAM_PARAMETERS\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/bin/Debug/net8.0-windows\" />\r\n      <option name=\"PASS_PARENT_ENVS\" value=\"1\" />\r\n      <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n      <option name=\"USE_MONO\" value=\"0\" />\r\n      <option name=\"RUNTIME_ARGUMENTS\" value=\"\" />\r\n      <option name=\"PROJECT_PATH\" value=\"$PROJECT_DIR$/AKG.csproj\" />\r\n      <option name=\"PROJECT_EXE_PATH_TRACKING\" value=\"1\" />\r\n      <option name=\"PROJECT_ARGUMENTS_TRACKING\" value=\"1\" />\r\n      <option name=\"PROJECT_WORKING_DIRECTORY_TRACKING\" value=\"1\" />\r\n      <option name=\"PROJECT_KIND\" value=\"StaticMethod\" />\r\n      <option name=\"PROJECT_TFM\" value=\"net8.0-windows\" />\r\n      <method v=\"2\">\r\n        <option name=\"Build\" />\r\n      </method>\r\n    </configuration>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"dd0a393e-b8c6-4340-bc02-58324722a279\" name=\"Changes\" comment=\"\" />\r\n      <created>1740513038705</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1740513038705</updated>\r\n      <workItem from=\"1740513039843\" duration=\"1009000\" />\r\n      <workItem from=\"1740593644092\" duration=\"2788000\" />\r\n      <workItem from=\"1740666964296\" duration=\"17561000\" />\r\n      <workItem from=\"1741345264898\" duration=\"1039000\" />\r\n      <workItem from=\"1741346328681\" duration=\"771000\" />\r\n      <workItem from=\"1741347109162\" duration=\"14096000\" />\r\n      <workItem from=\"1741607585981\" duration=\"14215000\" />\r\n      <workItem from=\"1743424079821\" duration=\"313000\" />\r\n      <workItem from=\"1743926736495\" duration=\"597000\" />\r\n      <workItem from=\"1744641107709\" duration=\"68000\" />\r\n      <workItem from=\"1745231844248\" duration=\"5668000\" />\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"refactoring\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1740752005663</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1740752005663</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"бебебе\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1741346169550</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1741346169550</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00003\" summary=\"lapa 2 almost done\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1741596372499</created>\r\n      <option name=\"number\" value=\"00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1741596372499</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00004\" summary=\"lapa 2, now it's full done\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1741615203074</created>\r\n      <option name=\"number\" value=\"00004\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1741615203074</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"5\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"UnityCheckinConfiguration\" checkUnsavedScenes=\"true\" />\r\n  <component name=\"UnityProjectConfiguration\" hasMinimizedUI=\"false\" />\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State>\r\n              <option name=\"FILTERS\">\r\n                <map>\r\n                  <entry key=\"branch\">\r\n                    <value>\r\n                      <list>\r\n                        <option value=\"main\" />\r\n                      </list>\r\n                    </value>\r\n                  </entry>\r\n                </map>\r\n              </option>\r\n            </State>\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <option name=\"CLEAR_INITIAL_COMMIT_MESSAGE\" value=\"true\" />\r\n    <MESSAGE value=\"refactoring\" />\r\n    <MESSAGE value=\"бебебе\" />\r\n    <MESSAGE value=\"lapa 2 almost done\" />\r\n    <MESSAGE value=\"lapa 2, now it's full done\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"lapa 2, now it's full done\" />\r\n  </component>\r\n  <component name=\"XDebuggerManager\">\r\n    <breakpoint-manager>\r\n      <breakpoints>\r\n        <line-breakpoint type=\"DotNet Breakpoints\">\r\n          <url>file://$PROJECT_DIR$/AKG/Program.cs</url>\r\n          <line>9</line>\r\n          <properties documentPath=\"C:\\BSUIR\\AKGv2\\AKG\\AKG\\Program.cs\" containingFunctionPresentation=\"Method 'Main'\" />\r\n          <option name=\"timeStamp\" value=\"1\" />\r\n        </line-breakpoint>\r\n      </breakpoints>\r\n    </breakpoint-manager>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/.idea.AKG/.idea/workspace.xml b/.idea/.idea.AKG/.idea/workspace.xml
--- a/.idea/.idea.AKG/.idea/workspace.xml	(revision dc8ea09344de44f0ccb8d230f234d3119f4cf238)
+++ b/.idea/.idea.AKG/.idea/workspace.xml	(date 1747219458620)
@@ -9,17 +9,14 @@
   <component name="ChangeListManager">
     <list default="true" id="dd0a393e-b8c6-4340-bc02-58324722a279" name="Changes" comment="">
       <change beforePath="$PROJECT_DIR$/.idea/.idea.AKG/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/.idea.AKG/.idea/workspace.xml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/AKG.sln.DotSettings.user" beforeDir="false" afterPath="$PROJECT_DIR$/AKG.sln.DotSettings.user" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/Drawing/BuffBitmap.cs" beforeDir="false" afterPath="$PROJECT_DIR$/Drawing/BuffBitmap.cs" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/Drawing/Painter.cs" beforeDir="false" afterPath="$PROJECT_DIR$/Drawing/Painter.cs" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/MainForm.cs" beforeDir="false" afterPath="$PROJECT_DIR$/MainForm.cs" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/Models/craneo.OBJ" beforeDir="false" />
       <change beforePath="$PROJECT_DIR$/Realization/Elements/Model.cs" beforeDir="false" afterPath="$PROJECT_DIR$/Realization/Elements/Model.cs" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Realization/MatrixTransformations.cs" beforeDir="false" afterPath="$PROJECT_DIR$/Realization/MatrixTransformations.cs" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/Realization/ObjParaser.cs" beforeDir="false" afterPath="$PROJECT_DIR$/Realization/ObjParaser.cs" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/bin/Debug/net8.0-windows/AKG.dll" beforeDir="false" afterPath="$PROJECT_DIR$/bin/Debug/net8.0-windows/AKG.dll" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/bin/Debug/net8.0-windows/AKG.exe" beforeDir="false" afterPath="$PROJECT_DIR$/bin/Debug/net8.0-windows/AKG.exe" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/bin/Debug/net8.0-windows/AKG.pdb" beforeDir="false" afterPath="$PROJECT_DIR$/bin/Debug/net8.0-windows/AKG.pdb" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/bin/Debug/net8.0-windows/AKG.runtimeconfig.json" beforeDir="false" afterPath="$PROJECT_DIR$/bin/Debug/net8.0-windows/AKG.runtimeconfig.json" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/bin/Debug/net8.0-windows/tmp.png" beforeDir="false" afterPath="$PROJECT_DIR$/bin/Debug/net8.0-windows/tmp.png" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/obj/AKG.csproj.nuget.dgspec.json" beforeDir="false" afterPath="$PROJECT_DIR$/obj/AKG.csproj.nuget.dgspec.json" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/obj/AKG.csproj.nuget.g.props" beforeDir="false" afterPath="$PROJECT_DIR$/obj/AKG.csproj.nuget.g.props" afterDir="false" />
@@ -71,7 +68,7 @@
     <setting file="file://$APPLICATION_CONFIG_DIR$/resharper-host/DecompilerCache/decompiler/211e6f3b24fa438a92f1815153647ce2c8f908/8e/00790cc9/Vector3.cs" root0="FORCE_HIGHLIGHTING" />
     <setting file="file://$APPLICATION_CONFIG_DIR$/resharper-host/DecompilerCache/decompiler/b6416db4533e4255bc43c1cfd556a910175930/47/1263af1a/Bitmap.cs" root0="FORCE_HIGHLIGHTING" />
     <setting file="file://$APPLICATION_CONFIG_DIR$/resharper-host/DecompilerCache/decompiler/ef7e03ede4ac4f90a806cf587e874b52208a0/42/71813ca3/KnownColor.cs" root0="FORCE_HIGHLIGHTING" />
-    <setting file="file://$APPLICATION_CONFIG_DIR$/resharper-host/SourcesCache/261ea83c988816e3d8fe76b15b7ac6c10af64b8f9e739854f83c137c8ba9/SafeFileHandle.Windows.cs" root0="FORCE_HIGHLIGHTING" />
+    <setting file="file://$APPLICATION_CONFIG_DIR$/resharper-host/SourcesCache/261ea83c988816e3d8fe76b15b7ac6c10af64b8f9e739854f83c137c8ba9/SafeFileHandle.Windows.cs" root0="SKIP_HIGHLIGHTING" />
     <setting file="file://$APPLICATION_CONFIG_DIR$/resharper-host/SourcesCache/2c8e7ca976f350cba9836d5565dac56b11e0b56656fa786460eb1395857a6fa/ThrowHelper.cs" root0="FORCE_HIGHLIGHTING" />
     <setting file="file://$APPLICATION_CONFIG_DIR$/resharper-host/SourcesCache/6ef8e7d549f6bfb5b9eafaaa0ff48d8cbfc564f32be26323b5f60e63aef4dd1/SafeFileHandle.Windows.cs" root0="FORCE_HIGHLIGHTING" />
     <setting file="file://$APPLICATION_CONFIG_DIR$/resharper-host/SourcesCache/72e5853ed6f2c1967eff9d6f0cf6ba12744c8978c516cbc5e74d992944ab/ArgumentOutOfRangeException.cs" root0="FORCE_HIGHLIGHTING" />
@@ -97,20 +94,20 @@
   <component name="ProjectViewState">
     <option name="showLibraryContents" value="true" />
   </component>
-  <component name="PropertiesComponent"><![CDATA[{
-  "keyToString": {
-    ".NET Project.AKG.executor": "Run",
-    "RunOnceActivity.ShowReadmeOnStart": "true",
-    "RunOnceActivity.git.unshallow": "true",
-    "git-widget-placeholder": "main",
-    "node.js.detected.package.eslint": "true",
-    "node.js.detected.package.tslint": "true",
-    "node.js.selected.package.eslint": "(autodetect)",
-    "node.js.selected.package.tslint": "(autodetect)",
-    "nodejs_package_manager_path": "npm",
-    "vue.rearranger.settings.migration": "true"
+  <component name="PropertiesComponent">{
+  &quot;keyToString&quot;: {
+    &quot;.NET Project.AKG.executor&quot;: &quot;Run&quot;,
+    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
+    &quot;RunOnceActivity.git.unshallow&quot;: &quot;true&quot;,
+    &quot;git-widget-placeholder&quot;: &quot;main&quot;,
+    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,
+    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,
+    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,
+    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,
+    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,
+    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;
   }
-}]]></component>
+}</component>
   <component name="RunManager">
     <configuration name="AKG" type="DotNetProject" factoryName=".NET Project">
       <option name="EXE_PATH" value="$PROJECT_DIR$/bin/Debug/net8.0-windows/AKG.dll" />
@@ -149,7 +146,8 @@
       <workItem from="1743424079821" duration="313000" />
       <workItem from="1743926736495" duration="597000" />
       <workItem from="1744641107709" duration="68000" />
-      <workItem from="1745231844248" duration="5668000" />
+      <workItem from="1745231844248" duration="19301000" />
+      <workItem from="1746646735673" duration="48000" />
     </task>
     <task id="LOCAL-00001" summary="refactoring">
       <option name="closed" value="true" />
@@ -183,7 +181,15 @@
       <option name="project" value="LOCAL" />
       <updated>1741615203074</updated>
     </task>
-    <option name="localTasksCounter" value="5" />
+    <task id="LOCAL-00005" summary="half of 4th laba">
+      <option name="closed" value="true" />
+      <created>1745237911404</created>
+      <option name="number" value="00005" />
+      <option name="presentableId" value="LOCAL-00005" />
+      <option name="project" value="LOCAL" />
+      <updated>1745237911404</updated>
+    </task>
+    <option name="localTasksCounter" value="6" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
@@ -202,7 +208,7 @@
                   <entry key="branch">
                     <value>
                       <list>
-                        <option value="main" />
+                        <option value="origin/main" />
                       </list>
                     </value>
                   </entry>
@@ -220,7 +226,8 @@
     <MESSAGE value="бебебе" />
     <MESSAGE value="lapa 2 almost done" />
     <MESSAGE value="lapa 2, now it's full done" />
-    <option name="LAST_COMMIT_MESSAGE" value="lapa 2, now it's full done" />
+    <MESSAGE value="half of 4th laba" />
+    <option name="LAST_COMMIT_MESSAGE" value="half of 4th laba" />
   </component>
   <component name="XDebuggerManager">
     <breakpoint-manager>
Index: obj/project.assets.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>{\r\n  \"version\": 3,\r\n  \"targets\": {\r\n    \"net8.0-windows7.0\": {}\r\n  },\r\n  \"libraries\": {},\r\n  \"projectFileDependencyGroups\": {\r\n    \"net8.0-windows7.0\": []\r\n  },\r\n  \"packageFolders\": {\r\n    \"C:\\\\Users\\\\Kangaschan\\\\.nuget\\\\packages\\\\\": {},\r\n    \"C:\\\\Program Files (x86)\\\\Microsoft Visual Studio\\\\Shared\\\\NuGetPackages\": {}\r\n  },\r\n  \"project\": {\r\n    \"version\": \"1.0.0\",\r\n    \"restore\": {\r\n      \"projectUniqueName\": \"E:\\\\6sem\\\\AkgGit\\\\AKG\\\\AKG\\\\AKG.csproj\",\r\n      \"projectName\": \"AKG\",\r\n      \"projectPath\": \"E:\\\\6sem\\\\AkgGit\\\\AKG\\\\AKG\\\\AKG.csproj\",\r\n      \"packagesPath\": \"C:\\\\Users\\\\Kangaschan\\\\.nuget\\\\packages\\\\\",\r\n      \"outputPath\": \"E:\\\\6sem\\\\AkgGit\\\\AKG\\\\AKG\\\\obj\\\\\",\r\n      \"projectStyle\": \"PackageReference\",\r\n      \"fallbackFolders\": [\r\n        \"C:\\\\Program Files (x86)\\\\Microsoft Visual Studio\\\\Shared\\\\NuGetPackages\"\r\n      ],\r\n      \"configFilePaths\": [\r\n        \"C:\\\\Users\\\\Kangaschan\\\\AppData\\\\Roaming\\\\NuGet\\\\NuGet.Config\",\r\n        \"C:\\\\Program Files (x86)\\\\NuGet\\\\Config\\\\Microsoft.VisualStudio.FallbackLocation.config\",\r\n        \"C:\\\\Program Files (x86)\\\\NuGet\\\\Config\\\\Microsoft.VisualStudio.Offline.config\"\r\n      ],\r\n      \"originalTargetFrameworks\": [\r\n        \"net8.0-windows\"\r\n      ],\r\n      \"sources\": {\r\n        \"C:\\\\Program Files (x86)\\\\Microsoft SDKs\\\\NuGetPackages\\\\\": {},\r\n        \"C:\\\\Program Files\\\\dotnet\\\\library-packs\": {},\r\n        \"https://api.nuget.org/v3/index.json\": {}\r\n      },\r\n      \"frameworks\": {\r\n        \"net8.0-windows7.0\": {\r\n          \"targetAlias\": \"net8.0-windows\",\r\n          \"projectReferences\": {}\r\n        }\r\n      },\r\n      \"warningProperties\": {\r\n        \"warnAsError\": [\r\n          \"NU1605\"\r\n        ]\r\n      },\r\n      \"restoreAuditProperties\": {\r\n        \"enableAudit\": \"true\",\r\n        \"auditLevel\": \"low\",\r\n        \"auditMode\": \"direct\"\r\n      },\r\n      \"SdkAnalysisLevel\": \"9.0.200\"\r\n    },\r\n    \"frameworks\": {\r\n      \"net8.0-windows7.0\": {\r\n        \"targetAlias\": \"net8.0-windows\",\r\n        \"imports\": [\r\n          \"net461\",\r\n          \"net462\",\r\n          \"net47\",\r\n          \"net471\",\r\n          \"net472\",\r\n          \"net48\",\r\n          \"net481\"\r\n        ],\r\n        \"assetTargetFallback\": true,\r\n        \"warn\": true,\r\n        \"frameworkReferences\": {\r\n          \"Microsoft.NETCore.App\": {\r\n            \"privateAssets\": \"all\"\r\n          },\r\n          \"Microsoft.WindowsDesktop.App.WindowsForms\": {\r\n            \"privateAssets\": \"none\"\r\n          }\r\n        },\r\n        \"runtimeIdentifierGraphPath\": \"C:\\\\Program Files\\\\dotnet\\\\sdk\\\\9.0.203/PortableRuntimeIdentifierGraph.json\"\r\n      }\r\n    }\r\n  }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/obj/project.assets.json b/obj/project.assets.json
--- a/obj/project.assets.json	(revision dc8ea09344de44f0ccb8d230f234d3119f4cf238)
+++ b/obj/project.assets.json	(date 1745507354455)
@@ -8,32 +8,29 @@
     "net8.0-windows7.0": []
   },
   "packageFolders": {
-    "C:\\Users\\Kangaschan\\.nuget\\packages\\": {},
+    "C:\\Users\\Admin\\.nuget\\packages\\": {},
     "C:\\Program Files (x86)\\Microsoft Visual Studio\\Shared\\NuGetPackages": {}
   },
   "project": {
     "version": "1.0.0",
     "restore": {
-      "projectUniqueName": "E:\\6sem\\AkgGit\\AKG\\AKG\\AKG.csproj",
+      "projectUniqueName": "C:\\BSUIR\\AKGv2\\AKG\\AKG.csproj",
       "projectName": "AKG",
-      "projectPath": "E:\\6sem\\AkgGit\\AKG\\AKG\\AKG.csproj",
-      "packagesPath": "C:\\Users\\Kangaschan\\.nuget\\packages\\",
-      "outputPath": "E:\\6sem\\AkgGit\\AKG\\AKG\\obj\\",
+      "projectPath": "C:\\BSUIR\\AKGv2\\AKG\\AKG.csproj",
+      "packagesPath": "C:\\Users\\Admin\\.nuget\\packages\\",
+      "outputPath": "C:\\BSUIR\\AKGv2\\AKG\\obj\\",
       "projectStyle": "PackageReference",
       "fallbackFolders": [
         "C:\\Program Files (x86)\\Microsoft Visual Studio\\Shared\\NuGetPackages"
       ],
       "configFilePaths": [
-        "C:\\Users\\Kangaschan\\AppData\\Roaming\\NuGet\\NuGet.Config",
-        "C:\\Program Files (x86)\\NuGet\\Config\\Microsoft.VisualStudio.FallbackLocation.config",
-        "C:\\Program Files (x86)\\NuGet\\Config\\Microsoft.VisualStudio.Offline.config"
+        "C:\\Users\\Admin\\AppData\\Roaming\\NuGet\\NuGet.Config",
+        "C:\\Program Files (x86)\\NuGet\\Config\\Microsoft.VisualStudio.FallbackLocation.config"
       ],
       "originalTargetFrameworks": [
         "net8.0-windows"
       ],
       "sources": {
-        "C:\\Program Files (x86)\\Microsoft SDKs\\NuGetPackages\\": {},
-        "C:\\Program Files\\dotnet\\library-packs": {},
         "https://api.nuget.org/v3/index.json": {}
       },
       "frameworks": {
@@ -52,7 +49,7 @@
         "auditLevel": "low",
         "auditMode": "direct"
       },
-      "SdkAnalysisLevel": "9.0.200"
+      "SdkAnalysisLevel": "9.0.100"
     },
     "frameworks": {
       "net8.0-windows7.0": {
@@ -68,6 +65,24 @@
         ],
         "assetTargetFallback": true,
         "warn": true,
+        "downloadDependencies": [
+          {
+            "name": "Microsoft.AspNetCore.App.Ref",
+            "version": "[8.0.12, 8.0.12]"
+          },
+          {
+            "name": "Microsoft.NETCore.App.Host.win-x64",
+            "version": "[8.0.12, 8.0.12]"
+          },
+          {
+            "name": "Microsoft.NETCore.App.Ref",
+            "version": "[8.0.12, 8.0.12]"
+          },
+          {
+            "name": "Microsoft.WindowsDesktop.App.Ref",
+            "version": "[8.0.12, 8.0.12]"
+          }
+        ],
         "frameworkReferences": {
           "Microsoft.NETCore.App": {
             "privateAssets": "all"
@@ -76,7 +91,7 @@
             "privateAssets": "none"
           }
         },
-        "runtimeIdentifierGraphPath": "C:\\Program Files\\dotnet\\sdk\\9.0.203/PortableRuntimeIdentifierGraph.json"
+        "runtimeIdentifierGraphPath": "C:\\Program Files\\dotnet\\sdk\\9.0.102/PortableRuntimeIdentifierGraph.json"
       }
     }
   }
Index: obj/AKG.csproj.nuget.g.props
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>\r\n<Project ToolsVersion=\"14.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\r\n  <PropertyGroup Condition=\" '$(ExcludeRestorePackageImports)' != 'true' \">\r\n    <RestoreSuccess Condition=\" '$(RestoreSuccess)' == '' \">True</RestoreSuccess>\r\n    <RestoreTool Condition=\" '$(RestoreTool)' == '' \">NuGet</RestoreTool>\r\n    <ProjectAssetsFile Condition=\" '$(ProjectAssetsFile)' == '' \">$(MSBuildThisFileDirectory)project.assets.json</ProjectAssetsFile>\r\n    <NuGetPackageRoot Condition=\" '$(NuGetPackageRoot)' == '' \">$(UserProfile)\\.nuget\\packages\\</NuGetPackageRoot>\r\n    <NuGetPackageFolders Condition=\" '$(NuGetPackageFolders)' == '' \">C:\\Users\\Kangaschan\\.nuget\\packages\\;C:\\Program Files (x86)\\Microsoft Visual Studio\\Shared\\NuGetPackages</NuGetPackageFolders>\r\n    <NuGetProjectStyle Condition=\" '$(NuGetProjectStyle)' == '' \">PackageReference</NuGetProjectStyle>\r\n    <NuGetToolVersion Condition=\" '$(NuGetToolVersion)' == '' \">6.13.2</NuGetToolVersion>\r\n  </PropertyGroup>\r\n  <ItemGroup Condition=\" '$(ExcludeRestorePackageImports)' != 'true' \">\r\n    <SourceRoot Include=\"C:\\Users\\Kangaschan\\.nuget\\packages\\\" />\r\n    <SourceRoot Include=\"C:\\Program Files (x86)\\Microsoft Visual Studio\\Shared\\NuGetPackages\\\" />\r\n  </ItemGroup>\r\n</Project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/obj/AKG.csproj.nuget.g.props b/obj/AKG.csproj.nuget.g.props
--- a/obj/AKG.csproj.nuget.g.props	(revision dc8ea09344de44f0ccb8d230f234d3119f4cf238)
+++ b/obj/AKG.csproj.nuget.g.props	(date 1745507343165)
@@ -5,12 +5,12 @@
     <RestoreTool Condition=" '$(RestoreTool)' == '' ">NuGet</RestoreTool>
     <ProjectAssetsFile Condition=" '$(ProjectAssetsFile)' == '' ">$(MSBuildThisFileDirectory)project.assets.json</ProjectAssetsFile>
     <NuGetPackageRoot Condition=" '$(NuGetPackageRoot)' == '' ">$(UserProfile)\.nuget\packages\</NuGetPackageRoot>
-    <NuGetPackageFolders Condition=" '$(NuGetPackageFolders)' == '' ">C:\Users\Kangaschan\.nuget\packages\;C:\Program Files (x86)\Microsoft Visual Studio\Shared\NuGetPackages</NuGetPackageFolders>
+    <NuGetPackageFolders Condition=" '$(NuGetPackageFolders)' == '' ">C:\Users\Admin\.nuget\packages\;C:\Program Files (x86)\Microsoft Visual Studio\Shared\NuGetPackages</NuGetPackageFolders>
     <NuGetProjectStyle Condition=" '$(NuGetProjectStyle)' == '' ">PackageReference</NuGetProjectStyle>
-    <NuGetToolVersion Condition=" '$(NuGetToolVersion)' == '' ">6.13.2</NuGetToolVersion>
+    <NuGetToolVersion Condition=" '$(NuGetToolVersion)' == '' ">6.12.2</NuGetToolVersion>
   </PropertyGroup>
   <ItemGroup Condition=" '$(ExcludeRestorePackageImports)' != 'true' ">
-    <SourceRoot Include="C:\Users\Kangaschan\.nuget\packages\" />
+    <SourceRoot Include="C:\Users\Admin\.nuget\packages\" />
     <SourceRoot Include="C:\Program Files (x86)\Microsoft Visual Studio\Shared\NuGetPackages\" />
   </ItemGroup>
 </Project>
\ No newline at end of file
